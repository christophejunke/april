;;;; spec.lisp

(in-package #:april)

(vex-spec
 april
 (state :count-from 1
	:disclose-output t
	:atomic-vector (concatenate 'string "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ"
				    "[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~¥€⇄∧∼≬⋆⋸⌸⌺⌼⌾⍁¡⍣⍅⎕⍞⌹⍆⍤⍇⍈⍊⊤λ⍍⍏"
				    "£⊥⍶⌶⍐⍑χ≢⍖⍗⍘⍚⍛⌈⍜⍢∪⍨⍕⍎⍬⍪∣│┤⍟∆∇→╣║╗╝←⌊┐└┴┬├─┼↑↓╔╚╩╦╠═╬≡⍸⍷∵⌷⍂⌻⊢⊣⋄┘┌█▄▌▐▀"
				    "⍺⍹⊂⊃⍝⍲⍴⍱⌽⊖○∨⍳⍉∈∩⌿⍀≥≤≠×÷⍙∘⍵⍫⍋⍒¯¨"))
 (grammar (:elements composer-elements-apl-standard)
	  (:opening-patterns composer-opening-patterns-apl-standard)
	  (:following-patterns composer-following-patterns-apl-standard))
 (utilities :match-blank-character (lambda (char) (member char (list #\  #\Tab)))
	    :match-newline-character (lambda (char) (member char (list #\◊ #\⋄ #\Newline #\Return)))
	    :match-token-character
	    (lambda (char)
	      (or (alphanumericp char)
		  (member char (list #\. #\∆ #\⍙ #\¯ #\⍺ #\⍵ #\⍬))))
	    :prep-code-string
	    (lambda (string)
	      ;; this code preprocessor removes comments, including comment-only lines
	      (regex-replace-all (concatenate 'string "^\\s{0,}⍝(.*)[\\r\\n]|(?<=[\\r\\n])\\s{0,}⍝(.*)[\\r\\n]"
					      "|(?<=[\\r\\n])\\s{0,}⍝(.*)[\\r\\n]"
					      "|(?<=[^\\r\\n])\\s{0,}⍝(.*)(?=[\\r\\n])")
				 string ""))
	    :process-axis-string (lambda (string) (cl-ppcre:split #\; string))
	    :format-value #'format-value
	    :format-object #'format-array
	    :format-function #'format-function
	    :mediate-operation-macro 'mediate-operation
	    :apply-scalar-monadic #'apply-scalar-monadic
	    :apply-scalar-dyadic #'apply-scalar-dyadic
	    :postprocess-compiled
	    (lambda (form)
	      ;; wrap the last element of the compiled output in a disclose form if discloseOutput is set
	      (if (of-state (local-idiom april) :disclose-output)
		  (append (butlast form)
			  (list (list 'disclose (first (last form)))))
		  form))
	    :postprocess-value
	    (lambda (item)
	      (if (of-state (local-idiom april) :disclose-output)
		  (list 'disclose item)
		  item))
	    :process-lexicon-macro 'april-function-glyph-processor)
 (functions
  (← (has :title "Assign")
     (symbolic :special-lexical-form-set)
     (tests (is "x←55 ⋄ x" 55)
	    (is "x←2 3 4⍴⍳9 ⋄ x[;1;]←7 ⋄ x" #3A(((7 7 7 7) (5 6 7 8) (9 1 2 3))
						((7 7 7 7) (8 9 1 2) (3 4 5 6))))))
  (⊣ (has :titles ("Empty" "Left"))
     (ambivalent (args :any (lambda (omega)
			      (declare (ignore omega))
			      (make-array (list 0))))
		 (args :any :any (lambda (omega alpha)
				   (declare (ignore omega))
				   alpha)))
     (tests (is "⊣77" #())
	    (is "55⊣77" 55)))
  (⊢ (has :titles ("Identity" "Right"))
     (ambivalent (args :any #'identity)
		 (args :any :any (lambda (omega alpha)
				   (declare (ignore alpha))
				   omega)))
     (tests (is "⊢77" 77)
	    (is "55⊢77" 77)))
  (+ (has :titles ("Conjugate" "Add"))
     (ambivalent :asymmetric-scalar conjugate +)
     (tests (is "+5" 5)
	    (is "+5J2" #C(5 -2))
	    (is "1+1" 2)
	    (is "1+1 2 3" #(2 3 4))))
  (- (has :titles ("Negate" "Subtract"))
     (ambivalent :symmetric-scalar (reverse-op -))
     (tests (is "2-1" 1)
	    (is "7-2 3 4" #(5 4 3))))
  (× (has :titles ("Sign" "Multiply"))
     (ambivalent :asymmetric-scalar signum *)
     (tests (is "×20 5 0 ¯5 5 ¯9" #(1 1 0 -1 1 -1))
	    (is "2×3" 6)
	    (is "4 5×8 9" #(32 45))))
  (÷ (has :titles ("Reciprocal" "Divide"))
     (ambivalent :symmetric-scalar (reverse-op /))
     (tests (is "6÷2" 3)
	    (is "12÷6 3 2" #(2 4 6))
	    (is "÷2 4 8" #(1/2 1/4 1/8))))
  (⋆ (has :titles ("Exponential" "Power"))
     (ambivalent :asymmetric-scalar exp (reverse-op expt))
     (tests (is "⌊1000×⋆2" 7389)
	    (is "2⋆4" 16)
	    (is "⌊16⋆÷2" 4)))
  (* (has :titles ("Exponential" "Power"))
     (ambivalent :asymmetric-scalar exp (reverse-op expt)))
  (⍟ (has :titles ("Natural Logarithm" "Logarithm"))
     (ambivalent :symmetric-scalar log)
     (tests (is "⌊1000×⍟5" 1609)
	    (is "⌊2⍟8" 3)))
  (\| (has :titles ("Magnitude" "Residue"))
      (ambivalent :asymmetric-scalar abs mod)
      (tests (is "|55" 55)
	     (is "|¯33" 33)
	     (is "8|39" 7)))
  (! (has :titles ("Factorial" "Binomial"))
     (ambivalent :asymmetric-scalar sprfact binomial)
     (tests (is "!5" 120)
	    (is "5!12" 792)))
  (⌈ (has :titles ("Ceiling" "Maximum"))
     (ambivalent :asymmetric-scalar ceiling (reverse-op max))
     (tests (is "⌈1.0001" 2)
	    (is "⌈1.9998" 2)
	    (is "3⌈0 1 2 3 4 5" #(3 3 3 3 4 5))))
  (⌊ (has :titles ("Floor" "Minimum"))
     (ambivalent :asymmetric-scalar floor (reverse-op min))
     (tests (is "⌊1.0001" 1)
	    (is "⌊1.9998" 1)
	    (is "3⌊0 1 2 3 4 5" #(0 1 2 3 3 3))))
  (? (has :titles ("Random" "Deal"))
     (ambivalent (scalar-function (lambda (omega)
				    (+ index-origin (random omega))))
		 (lambda (omega alpha)
		   (let ((omega (disclose omega))
			 (alpha (disclose alpha)))
		     (if (or (not (integerp omega))
			     (not (integerp alpha)))
			 (error "Both arguments to ? must be single integers.")
			 (make-array (list alpha)
				     :initial-contents
				     (loop :for i :from 0 :to (1- alpha)
					:collect (+ index-origin (random omega)))))))))
  (○ (has :titles ("Pi Times" "Circular"))
     (ambivalent (scalar-function (lambda (omega) (* pi omega)))
		 (lambda (omega alpha)
		   (let ((alpha (disclose alpha)))
		     (if (not (numberp alpha))
			 (error "The left argument to ○ must be a single number, i.e. 2○10.")
			 ;; the twelfth element of the vector corresponds to
			 ;; index 0, hence an offset of 12 from the vector's first element
			 (apply-scalar-monadic (aref *circular-functions* (+ 12 alpha))
					       omega)))))
     (tests (is "⌊100000×○1" 314159)
	    (is "(⌊1000×1÷2⋆÷2)=⌊1000×1○○÷4" 1)))
  (\~ (has :titles ("Not" "Without"))
      (ambivalent (scalar-function (lambda (omega)
				     (cond ((= 0 omega) 1)
					   ((= 1 omega) 0)
					   (t (error "Domain error: arguments to ~ must be 1 or 0.")))))
		  (lambda (omega alpha)
		    (let ((to-exclude (if (stringp omega)
					  (array-to-list omega)
					  (array-to-list (make-array
							  (list (array-total-size omega))
							  :displaced-to omega))))
			  (included nil))
		      (aops:each (lambda (element)
				   (if (not (member element to-exclude))
				       (setq included (cons element included))))
				 alpha)
		      (make-array (list (length included))
				  :element-type (element-type alpha)
				  :initial-contents (reverse included)))))
      (tests (is "~1 0 1" #(0 1 0))
	     (is "1 2 3 4 5 6 7~3 5" #(1 2 4 6 7))
	     (is "'MACARONI'~'ALFREDO'" "MCNI")))
  (< (has :title "Less")
     (dyadic (scalar-function (reverse-boolean-op <)))
     (tests (is "3<1 2 3 4 5" #(0 0 0 1 1))))
  (≤ (has :title "Less or Equal")
     (dyadic (scalar-function (reverse-boolean-op <=)))
     (tests (is "3≤1 2 3 4 5" #(0 0 1 1 1))))
  (= (has :title "Equal")
     (dyadic (scalar-function (boolean-op (lambda (omega alpha)
					    (funcall (cond ((and (numberp alpha)
								 (numberp omega))
							    #'=)
							   ((and (characterp alpha)
								 (characterp omega))
							    #'char=))
						     omega alpha)))))
     (tests (is "3=1 2 3 4 5" #(0 0 1 0 0))))
  (≥ (has :title "Greater or Equal")
     (dyadic (scalar-function (boolean-op >=)))
     (tests (is "3≥1 2 3 4 5" #(1 1 1 0 0))))
  (> (has :title "Greater")
     (dyadic (scalar-function (boolean-op >)))
     (tests (is "3>1 2 3 4 5" #(1 1 0 0 0))))
  (≠ (has :title "Not Equal")
     (dyadic (scalar-function (boolean-op /=)))
     (tests (is "3≠1 2 3 4 5" #(1 1 0 1 1))))
  (≡ (has :titles ("Depth" "Match"))
     (ambivalent #'array-depth
		 (boolean-op array-compare))
     (tests (is "≡1 (2 3) (4 5 (6 7)) (8)" 3)))
  (≢ (has :titles ("First Dimension" "Not Match"))
     (ambivalent (lambda (omega) (first (dims omega)))
		 (boolean-op (lambda (omega alpha)
			       (not (array-compare omega alpha)))))
     (tests (is "≢1 2 3" 3)
	    (is "≢2 3 4⍴⍳9" 2)))
  (^ (has :title "And")
     (dyadic (scalar-function (reverse-op lcm))))
  (∧ (has :title "And")
     (dyadic (scalar-function (reverse-op lcm)))
     (tests (is "0 1 0 1 ∧ 0 0 1 1" #(0 0 0 1))))
  (⍲ (has :title "Nand")
     (dyadic (scalar-function (boolean-op (lambda (omega alpha) (not (= omega alpha 1))))))
     (tests (is "0 1 0 1 ⍲ 0 0 1 1" #(1 1 1 0))))
  (∨ (has :title "Or")
     (dyadic (scalar-function (reverse-op gcd)))
     (tests (is "0 1 0 1 ∨ 0 0 1 1" #(0 1 1 1))))
  (⍱ (has :title "Nor")
     (dyadic (scalar-function (boolean-op (lambda (omega alpha) (= omega alpha 0)))))
     (tests (is "0 1 0 1 ⍱ 0 0 1 1" #(1 0 0 0))))
  (⍳ (has :titles ("Index" "Index Of"))
     (ambivalent (lambda (omega)
		   (let ((omega (disclose omega)))
		     (if (not (integerp omega))
			 (error "The argument to ⍳ must be a single integer, i.e. ⍳9.")
			 (make-array (list omega)
				     :initial-contents
				     (iota omega :start index-origin)))))
		 (lambda (omega alpha) (index-of omega alpha index-origin)))
     (tests (is "⍳5" #(1 2 3 4 5))
	    (is "3⍳1 2 3 4 5" #(2 2 1 2 2))))
  (⍴ (has :titles ("Shape" "Reshape"))
     (ambivalent (lambda (omega)
		   (let ((omega-dims (dims omega)))
		     (make-array (list (length omega-dims))
				 :initial-contents omega-dims)))
		 (lambda (omega alpha) (reshape-array-fitting omega (array-to-list alpha))))
     (tests (is "⍴1 2 3" 3)
	    (is "⍴3 5⍴⍳8" #(3 5))
	    (is "4 5⍴⍳3" #2A((1 2 3 1 2) (3 1 2 3 1) (2 3 1 2 3) (1 2 3 1 2)))))
  (⌷ (has :title "At Axes")
     (dyadic (lambda (omega alpha &optional axes)
	       (if axes (let ((elided-coords (loop :for i :from 0 :to (1- (rank omega))
						:collect nil)))
			  (loop :for index :from 0 :to (1- (length (first axes)))
			     :do (setf (nth (- (aref (first axes) index)
					       index-origin)
					    elided-coords)
				       (list (- (aref alpha index)
						index-origin))))
			  (aref-eliding omega elided-coords))
		   (let* ((coords (mapcar (lambda (coord) (- coord index-origin))
					  (array-to-list alpha)))
			  (found (apply #'aref (cons omega coords))))
		     (if (not (arrayp found))
			 (vector found)
			 found)))))
     (tests (is "3⌷⍳9" 3)
	    (is "2 2⌷4 5⍴⍳9" 7)
	    (is "2 3 4⌷4 5 6⍴⍳9" 1)
	    (is "1 3⌷[1 2]2 3 4⍴⍳5" #(4 5 1 2))))
  (∊ (has :titles ("Enlist" "Membership"))
     (ambivalent #'enlist
		 (lambda (omega alpha)
		   (let ((output (make-array (dims alpha))))
		     (dotimes (index (array-total-size output))
		       (let ((found nil))
			 (aops:each (lambda (input)
				      (cond ((and (numberp input)
						  (numberp (row-major-aref alpha index))
						  (= input (row-major-aref alpha index)))
					     (setq found t))
					    ((and (characterp input)
						  (characterp (row-major-aref alpha
									      index))
						  (char= input (row-major-aref alpha index)))
					     (setq found t))))
				    omega)
			 (setf (row-major-aref output index)
			       (if found 1 0))))
		     output)))
     (tests (is "∊2 2 2⍴⍳9" #(1 2 3 4 5 6 7 8))
	    (is "2 5 7∊1 2 3 4 5" #(1 1 0))))
  (⍷ (has :title "Find")
     (dyadic #'find-array)
     (tests (is "(2 2⍴6 7 1 2)⍷2 3 4⍴⍳9" #3A(((0 0 0 0) (0 1 0 0) (0 0 0 0))
					     ((0 0 1 0) (0 0 0 0) (0 0 0 0))))))
  (⍸ (has :titles ("Where" "Interval Index"))
     (ambivalent (lambda (omega)
		   (let ((indices nil)
			 (match-count 0)
			 (orank (rank omega)))
		     (run-dim omega
			      (lambda (index coords)
				(if (= 1 index)
				    (let ((coords (mapcar (lambda (i) (+ i index-origin))
							  coords)))
				      (incf match-count)
				      (setq indices (cons (if (< 1 orank)
							      (make-array (list orank)
									  :initial-contents coords)
							      (first coords))
							  indices))))))
		     (make-array (list match-count) :initial-contents (reverse indices))))
		 (lambda (omega alpha)
		   ;; TODO: add higher rank and nested functionality
		   (aops:each (lambda (oitem)
				(let ((match 0))
				  (loop :for index :from 0 :to (1- (length alpha))
				     :while (if (numberp oitem)
						(if (numberp (aref alpha index))
						    (> oitem (aref alpha index))
						    (error "Incompatible arrays."))
						(if (characterp oitem)
						    (if (characterp (aref alpha index))
							(funcall (alpha-compare atomic-vector #'>)
								 oitem (aref alpha index))
							(error "Incompatible arrays."))))
				     :do (incf match))
				  match))
			      omega)))
     (tests (is "⍸0 0 1 0 1 0 0 1 1 0" #(3 5 8 9))
	    (is "⍸3=2 3 4⍴⍳9" #(#(1 1 3) #(1 3 4) #(2 3 1)))
	    (is "10 20 30 40⍸5 12 19 24 35 42 51" #(0 1 1 2 3 4 4))))
  (↑ (has :titles ("Disclose" "Take"))
     (ambivalent #'disclose
		 (lambda (omega alpha &optional axes)
		   (multidim-slice omega (if axes
					     (loop :for axis :from 0 :to (1- (rank omega))
						:collect (if (= axis (- (aref (first axes) 0)
									index-origin))
							     (aref alpha 0)
							     (nth axis (dims omega))))
					     (array-to-list alpha))
				   :fill-with 0)))
     (tests (is "↑⊂1 2 3 4" #(1 2 3 4))
	    (is "¯1↑⍳5" 5)
	    (is "2 3 4↑4 5 6⍴⍳9" #3A(((1 2 3 4) (7 8 9 1) (4 5 6 7))
				     ((4 5 6 7) (1 2 3 4) (7 8 9 1))))
	    (is "2 ¯2 ¯2↑4 5 6⍴⍳9" #3A(((5 6) (2 3)) ((8 9) (5 6))))
	    (is "1↑[1]2 3 4⍴⍳9" #3A(((1 2 3 4) (5 6 7 8) (9 1 2 3))))
	    (is "1↑[2]2 3 4⍴⍳9" #3A(((1 2 3 4)) ((4 5 6 7))))
	    (is "2↑[2]2 3 4⍴⍳9" #3A(((1 2 3 4) (5 6 7 8)) ((4 5 6 7) (8 9 1 2))))
	    (is "2↑[3]2 3 4⍴⍳9" #3A(((1 2) (5 6) (9 1)) ((4 5) (8 9) (3 4))))))
  (↓ (has :titles ("Split" "Drop"))
     (ambivalent (lambda (omega &optional axes)
		   (aops:split omega (if axes (aref (first axes) 0)
					 (1- (rank omega)))))
		 (lambda (omega alpha &optional axes)
		   (multidim-slice omega
				   (if axes (loop :for axis :from 0 :to (1- (rank omega))
					       :collect (if (= axis (- (aref (first axes) 0)
								       index-origin))
							    (aref alpha 0)
							    0))
				       (array-to-list alpha))
				   :inverse t)))
     (tests (is "↓3 4⍴⍳9" #(#(1 2 3 4) #(5 6 7 8) #(9 1 2 3)))
	    (is "2 2 2↓4 5 6⍴⍳9" #3A(((3 4 5 6) (9 1 2 3) (6 7 8 9))
				     ((6 7 8 9) (3 4 5 6) (9 1 2 3))))
	    (is "1↓[1]2 3 4⍴⍳9" #3A(((4 5 6 7) (8 9 1 2) (3 4 5 6))))
	    (is "1↓[2]2 3 4⍴⍳9" #3A(((5 6 7 8) (9 1 2 3)) ((8 9 1 2) (3 4 5 6))))
	    (is "2↓[2]2 3 4⍴⍳9" #3A(((9 1 2 3)) ((3 4 5 6))))
	    (is "2↓[3]2 3 4⍴⍳9" #3A(((3 4) (7 8) (2 3)) ((6 7) (1 2) (5 6))))
	    (is "¯2↓⍳9" #(1 2 3 4 5 6 7))
	    (is "¯2 ¯2↓5 8⍴⍳9" #2A((1 2 3 4 5 6) (9 1 2 3 4 5) (8 9 1 2 3 4)))))
  (\, (has :titles ("Ravel" "Catenate or Laminate"))
      (ambivalent (lambda (omega &optional axes)
		    (ravel index-origin omega axes))
		  (lambda (omega alpha &optional axes)
		    (if (and (or (not axes)
				 (integerp (aref (first axes) 0)))
			     (vectorp alpha)
			     (vectorp omega))
			(if (and axes (< 0 (- (aref (first axes) 0)
					      index-origin)))
			    (error (concatenate
				    'string "Specified axis is greater than 1, vectors"
				    " have only one axis along which to catenate."))
			    (if (and axes (> 0 (- (aref (first axes) 0)
						  index-origin)))
				(error (format nil "Specified axis is less than ~a." index-origin))
				(concatenate 'vector alpha omega)))
			(if (or (not axes)
				(integerp (aref (first axes) 0)))
			    (let* ((axis (if axes (- (aref (first axes) 0)
						     index-origin)
					     (1- (max (array-rank alpha)
						      (array-rank omega)))))
				   (scale-alpha (if (not (is-unitary alpha))
						    alpha (scale-array alpha omega axis)))
				   (scale-omega (if (not (is-unitary omega))
						    omega (scale-array omega alpha axis))))
			      (aops:stack axis scale-alpha scale-omega))
			    ;; laminate in the case of a fractional axis argument
			    (let* ((axis (ceiling (- (aref (first axes) 0)
						     index-origin)))
				   (permute-dims (alexandria:iota (1+ (rank alpha))))
				   (p-alpha (if (not (is-unitary alpha))
						(aops:permute (rotate-right axis permute-dims)
							      (array-promote alpha))))
				   (p-omega (if (not (is-unitary omega))
						(aops:permute (rotate-right axis permute-dims)
							      (array-promote omega)))))
			      ;; a 1-element array argument to laminate is scaled to
			      ;; match the other array's dimensions
			      (aops:stack axis (if (is-unitary alpha)
						   (scale-array alpha p-omega)
						   p-alpha)
					  (if (is-unitary omega)
					      (scale-array omega p-alpha)
					      p-omega)))))))
      (tests (is ",3 4⍴⍳9" #(1 2 3 4 5 6 7 8 9 1 2 3))
	     (is ",[0.5]3 4⍴⍳9" #3A(((1 2 3 4) (5 6 7 8) (9 1 2 3))))
	     (is ",[1.5]3 4⍴⍳9" #3A(((1 2 3 4)) ((5 6 7 8)) ((9 1 2 3))))
	     (is ",[2.5]3 4⍴⍳9" #3A(((1) (2) (3) (4)) ((5) (6) (7) (8)) ((9) (1) (2) (3))))
	     (is ",[1 2]2 3 3⍴⍳12" #2A((1 2 3) (4 5 6) (7 8 9) (10 11 12) (1 2 3) (4 5 6)))
	     (is ",[2 3]2 3 3⍴⍳12" #2A((1 2 3 4 5 6 7 8 9) (10 11 12 1 2 3 4 5 6)))
	     (is ",[1 2 3]2 3 3⍴⍳12" #(1 2 3 4 5 6 7 8 9 10 11 12 1 2 3 4 5 6))
	     (is "0,3 4⍴⍳9" #2A((0 1 2 3 4) (0 5 6 7 8) (0 9 1 2 3)))
	     (is "0,[1]3 4⍴⍳9" #2A((0 0 0 0) (1 2 3 4) (5 6 7 8) (9 1 2 3)))
	     (is "(3 6⍴⍳6),3 4⍴⍳9" #2A((1 2 3 4 5 6 1 2 3 4) (1 2 3 4 5 6 5 6 7 8)
				       (1 2 3 4 5 6 9 1 2 3)))
	     (is "(5 4⍴⍳6),[1]3 4⍴⍳9" #2A((1 2 3 4) (5 6 1 2) (3 4 5 6) (1 2 3 4)
					  (5 6 1 2) (1 2 3 4) (5 6 7 8) (9 1 2 3)))
	     (is "1 2 3,4 5 6" #(1 2 3 4 5 6))
	     (is "1 2 3,[1]4 5 6" #(1 2 3 4 5 6))
	     (is "1 2 3 4,[0.5]1 2 3 4" #2A((1 2 3 4) (1 2 3 4)))
	     (is "1 2 3 4,[1.5]1 2 3 4" #2A((1 1) (2 2) (3 3) (4 4)))
	     (is "(2 3⍴⍳9),[0.5]2 3⍴⍳9" #3A(((1 2 3) (4 5 6)) ((1 2 3) (4 5 6))))
	     (is "(2 3⍴⍳9),[2.5]2 3⍴⍳9" #3A(((1 1) (2 2) (3 3)) ((4 4) (5 5) (6 6))))
	     (is "'UNDER',[0.5]'-'" #2A((#\U #\N #\D #\E #\R) (#\- #\- #\- #\- #\-)))
	     (is "'HELLO',[1.5]'.'" #2A((#\H #\.) (#\E #\.) (#\L #\.) (#\L #\.) (#\O #\.)))))
  (⍪ (has :titles ("Table" "Catenate First"))
     (ambivalent (lambda (omega) (if (vectorp omega)
				     (make-array (list (length omega) 1)
						 :element-type (element-type omega)
						 :initial-contents
						 (loop :for i :from 0 :to (1- (length omega))
						    :collect (list (aref omega i))))
				     (let ((o-dims (dims omega)))
				       (make-array (list (first o-dims)
							 (apply #'* (rest o-dims)))
						   :element-type (element-type omega)
						   :displaced-to (copy-array omega)))))
		 (lambda (omega alpha &optional axes)
		   (if (and (vectorp alpha)
			    (vectorp omega))
		       (if (and axes (< 0 (- (aref (first axes) 0)
					     index-origin)))
			   (error (concatenate
				   'string "Specified axis is greater than 1, vectors"
				   " have only one axis along which to catenate."))
			   (if (and axes (> 0 (- (aref (first axes) 0)
						 index-origin)))
			       (error (format nil "Specified axis is less than ~a." index-origin))
			       (concatenate 'vector alpha omega)))
		       (if (or (not axes)
			       (integerp (aref (first axes) 0)))
			   (let* ((axis (if axes (- (aref (first axes) 0)
						    index-origin)
					    0))
				  (scale-alpha (if (not (is-unitary alpha))
						   alpha (scale-array alpha omega axis)))
				  (scale-omega (if (not (is-unitary omega))
						   omega (scale-array omega alpha axis))))
			     (aops:stack axis scale-alpha scale-omega))))))
     (tests (is "⍪'MAKE'" #2A((#\M) (#\A) (#\K) (#\E)))
	    (is "⍪3 4⍴⍳9" #2A((1 2 3 4) (5 6 7 8) (9 1 2 3)))
	    (is "⍪2 3 4⍴⍳24" #2A((1 2 3 4 5 6 7 8 9 10 11 12)
				 (13 14 15 16 17 18 19 20 21 22 23 24)))
	    (is "0⍪3 4⍴⍳9" #2A((0 0 0 0) (1 2 3 4) (5 6 7 8) (9 1 2 3)))
	    (is "0⍪[2]3 4⍴⍳9" #2A((0 1 2 3 4) (0 5 6 7 8) (0 9 1 2 3)))
	    (is "(5 4⍴⍳6)⍪3 4⍴⍳9" #2A((1 2 3 4) (5 6 1 2) (3 4 5 6) (1 2 3 4)
				      (5 6 1 2) (1 2 3 4) (5 6 7 8) (9 1 2 3)))
	    (is "(3 6⍴⍳6)⍪[2]3 4⍴⍳9" #2A((1 2 3 4 5 6 1 2 3 4) (1 2 3 4 5 6 5 6 7 8)
					 (1 2 3 4 5 6 9 1 2 3)))))
  (/ (has :title "Replicate")
     (dyadic (lambda (omega alpha &optional axes)
	       (expand-array (array-to-list alpha)
			     omega (if axes (- (rank omega)
					       (- (aref (first axes) 0)
						  (1- index-origin))))
			     0 :compress-mode t)))
     (tests (is "5/3" #(3 3 3 3 3))
	    (is "1 0 1 0 1/⍳5" #(1 3 5))
	    (is "3/⍳5" #(1 1 1))
	    (is "3/⊂⍳5" #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))
	    (is "1 ¯2 3 ¯4 5/3 5⍴⍳5" #2A((1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
					 (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
					 (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)))
	    (is "1 ¯2 3/[1]3 5⍴⍳9" #2A((1 2 3 4 5) (0 0 0 0 0) (0 0 0 0 0)
				       (2 3 4 5 6) (2 3 4 5 6) (2 3 4 5 6)))))
  (⌿ (has :title "Replicate First")
     (dyadic (lambda (omega alpha &optional axes)
	       (expand-array (array-to-list alpha)
			     omega (if axes (- (rank omega)
					       (- (aref (first axes) 0)
						  (1- index-origin))))
			     (1- (rank omega))
			     :compress-mode t)))
     (tests (is "1 0 1 0 1⌿⍳5" #(1 3 5))
	    (is "1 ¯2 3⌿3 5⍴⍳9" #2A((1 2 3 4 5) (0 0 0 0 0) (0 0 0 0 0)
				    (2 3 4 5 6) (2 3 4 5 6) (2 3 4 5 6)))
	    (is "1 ¯2 3 ¯4 5⌿[2]3 5⍴⍳5" #2A((1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
					    (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
					    (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)))))
  (\\ (has :title "Expand")
      (dyadic (lambda (omega alpha &optional axes)
		(expand-array (array-to-list alpha)
			      omega (if axes (- (rank omega)
						(- (aref (first axes) 0)
						   (1- index-origin))))
			      0)))
      (tests (is "1 ¯2 3 ¯4 5\\ '.'" ".  ...    .....")
	     (is "1 ¯2 2 0 1\\3+2 3⍴⍳6" #2A((4 0 0 5 5 0 6) (7 0 0 8 8 0 9)))
	     (is "1 0 1\\[1]3+2 3⍴⍳6" #2A((4 5 6) (0 0 0) (7 8 9)))))
  (⍀ (has :title "Expand First")
     (dyadic (lambda (omega alpha &optional axes)
	       (expand-array (array-to-list alpha)
			     omega (if axes (- (rank omega)
					       (- (aref (first axes) 0)
						  (1- index-origin))))
			     (1- (rank omega)))))
     (tests (is "1 ¯2 3 ¯4 5⍀3" #(3 0 0 3 3 3 0 0 0 0 3 3 3 3 3))
	    (is "1 0 1⍀3+2 3⍴⍳6" #2A((4 5 6) (0 0 0) (7 8 9)))))
  (⊂ (has :titles ("Enclose" "Partition"))
     (ambivalent (lambda (omega &optional axes)
		   (if axes (re-enclose omega (aops:each (lambda (axel) (- axel index-origin))
							 (first axes)))
		       (if (loop :for dim :in (dims omega) :always (= 1 dim))
			   omega (make-array (list 1) :initial-element omega))))
		 (lambda (omega alpha)
		   (if (/= (length alpha) (length omega))
		       (error "Length mismatch.")
		       (let ((output nil)
			     (accumulator nil)
			     (partition-index 0))
			 (dotimes (index (length alpha))
			   (if (and (< 0 index)
				    (< partition-index (aref alpha index)))
			       (progn (setq output
					    (cons (make-array (list (length accumulator))
							      :initial-contents (reverse accumulator))
						  output))
				      (setq accumulator nil)))
			   (setq partition-index (aref alpha index))
			   (if (< 0 (aref alpha index))
			       (setq accumulator (cons (aref omega index)
						       accumulator))))
			 (if accumulator (setq output (cons (make-array (list (length accumulator))
									:initial-contents (reverse accumulator))
							    output)))
			 (make-array (list (length output))
				     :initial-contents (reverse output))))))
     (tests (is "1,⊂3 4⍴⍳7" #(1 #2A((1 2 3 4) (5 6 7 1) (2 3 4 5))))
	    (is "⊂[3]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
		#2A(("GRAY" "GOLD" "BLUE") ("SILK" "WOOL" "YARN")))
	    (is "⊂[2]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
		#2A(("GGB" "ROL" "ALU" "YDE") ("SWY" "IOA" "LOR" "KLN")))
	    (is "⊂[1]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
		#2A(("GS" "RI" "AL" "YK") ("GW" "OO" "LO" "DL") ("BY" "LA" "UR" "EN")))
	    (is "⊂[2 3]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
		#(#2A((#\G #\R #\A #\Y) (#\G #\O #\L #\D) (#\B #\L #\U #\E))
		  #2A((#\S #\I #\L #\K) (#\W #\O #\O #\L) (#\Y #\A #\R #\N))))
	    (is "⊂[1 3]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
		#(#2A((#\G #\R #\A #\Y) (#\S #\I #\L #\K))
		  #2A((#\G #\O #\L #\D) (#\W #\O #\O #\L))
		  #2A((#\B #\L #\U #\E) (#\Y #\A #\R #\N))))
	    (is "⊂[1 2]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
		#(#2A((#\G #\G #\B) (#\S #\W #\Y)) #2A((#\R #\O #\L) (#\I #\O #\A))
		  #2A((#\A #\L #\U) (#\L #\O #\R)) #2A((#\Y #\D #\E) (#\K #\L #\N))))
	    (is "1 1 2 2 2 3 3 3 3⊂⍳9" #(#(1 2) #(3 4 5) #(6 7 8 9)))))
  (⍧ (has :title "Partitioned Enclose")
     (dyadic (lambda (omega alpha &optional axes)
	       (partitioned-enclose alpha omega
				    (if axes (- (rank omega)
						(- (aref (first axes) 0)
						   (1- index-origin))))
				    0)))
     (tests (is "0 1 0 0 1 1 0 0 0⍧⍳9" #(#(2 3 4) #(5) #(6 7 8 9)))
	    (is "0 1 0 0 1 1 0 0 0⍧4 8⍴⍳9"
		#(#2A((2 3 4) (1 2 3) (9 1 2) (8 9 1)) #2A((5) (4) (3) (2))
		  #2A((6 7 8) (5 6 7) (4 5 6) (3 4 5))))
	    (is "0 1 0 1 0⍧[1]4 8⍴⍳9"
		#(#2A((9 1 2 3 4 5 6 7) (8 9 1 2 3 4 5 6)) #2A((7 8 9 1 2 3 4 5))))))
  (⊃ (has :titles ("Mix" "Pick"))
     (ambivalent (lambda (omega &optional axes)
		   (mix-arrays (if axes (ceiling (- (1+ (rank omega))
						    (aref (first axes) 0)
						    index-origin))
				   0)
			       omega))
		 (lambda (omega alpha)
		   (labels ((layer-index (object indices)
			      (if indices
				  (layer-index (aref object (- (first indices)
							       index-origin))
					       (rest indices))
				  object)))
		     (let ((found (layer-index omega (array-to-list alpha))))
		       (if (arrayp found)
			   found (make-array (list 1)
					     :element-type (element-type omega)
					     :initial-element found))))))
     (tests (is "⊃(1)(1 2)(1 2 3)" #2A((1 0 0) (1 2 0) (1 2 3)))
	    (is "⊃[0.5](1)(1 2)(1 2 3)" #2A((1 1 1) (0 2 2) (0 0 3)))
	    (is "⊃(2 3⍴⍳5)(4 2⍴⍳8)" #3A(((1 2 3) (4 5 1) (0 0 0) (0 0 0))
					((1 2 0) (3 4 0) (5 6 0) (7 8 0))))
	    (is "⊃[0.5](2 3⍴⍳5)(4 2⍴⍳8)" #3A(((1 4 0 0) (1 3 5 7)) ((2 5 0 0) (2 4 6 8))
					     ((3 1 0 0) (0 0 0 0))))
	    (is "⊃[1.5](2 3⍴⍳5)(4 2⍴⍳8)" #3A(((1 2 3) (4 5 1) (0 0 0) (0 0 0))
					     ((1 2 0) (3 4 0) (5 6 0) (7 8 0))))
	    (is "⊃2 2 2⍴(1)(1 2)(3 4)(1 2 3)" #4A((((1 0 0) (1 2 0)) ((3 4 0) (1 2 3)))
						  (((1 0 0) (1 2 0)) ((3 4 0) (1 2 3)))))
	    (is "2⊃(1 2 3)(4 5 6)(7 8 9)" #(4 5 6))
	    (is "(2 2)⊃(1 2 3)(4 5 6)(7 8 9)" 5)))
  (∪ (has :titles ("Unique" "Union"))
     (ambivalent (lambda (omega)
		   (if (not (vectorp omega))
		       (error "Argument must be a vector.")
		       (let ((uniques nil))
			 (dotimes (index (length omega))
			   (if (not (find (aref omega index)
					  uniques :test #'array-compare))
			       (setq uniques (cons (aref omega index)
						   uniques))))
			 (make-array (list (length uniques))
				     :element-type (element-type omega)
				     :initial-contents (reverse uniques)))))
		 (lambda (omega alpha)
		   (if (or (not (vectorp alpha))
			   (not (vectorp omega)))
		       (error "Arguments must be vectors.")
		       (let ((uniques nil)
			     (is-string (and (eql 'character (element-type alpha))
					     (eql 'character (element-type omega)))))
			 (dotimes (index (length omega))
			   (if (not (find (aref omega index)
					  alpha :test #'array-compare))
			       (setq uniques (cons (aref omega index)
						   uniques))))
			 (concatenate (if is-string 'string 'vector)
				      alpha (make-array (list (length uniques))
							:element-type (if is-string 'character t)
							:initial-contents (reverse uniques)))))))
     (tests (is "∪1 2 3 4 5 1 2 8 9 10 11 7 8 11 12" #(1 2 3 4 5 8 9 10 11 7 12))
	    (is "∪'MISSISSIPPI'" "MISP")
	    (is "3 10 14 18 11∪9 4 5 10 8 3" #(3 10 14 18 11 9 4 5 8))
	    (is "'STEEL'∪'SABER'" "STEELABR")
	    (is "'APRIL' 'MAY'∪'MAY' 'JUNE'" #("APRIL" "MAY" "JUNE"))))
  (∩ (has :title "Intersection")
     (dyadic (lambda (omega alpha)
	       (if (or (not (vectorp alpha))
		       (not (vectorp omega)))
		   (error "Arguments must be vectors.")
		   (let ((matches nil)
			 (is-string (and (eql 'character (element-type alpha))
					 (eql 'character (element-type omega)))))
		     (dotimes (index (length alpha))
		       (if (find (aref alpha index)
				 omega :test #'array-compare)
			   (setq matches (cons (aref alpha index)
					       matches))))
		     (make-array (list (length matches))
				 :element-type (if is-string 'character t)
				 :initial-contents (reverse matches))))))
     (tests (is "'MIXTURE'∩'LATER'" "TRE")
	    (is "'STEEL'∩'SABER'" "SEE")
	    (is "1 4 8∩⍳5" #(1 4))))
  (⌽ (has :titles ("Reverse" "Rotate"))
     (ambivalent (lambda (omega &optional axes)
		   (let ((axis (- (if axes (aref (first axes) 0)
				      (rank omega))
				  index-origin)))
		     (if (vectorp omega)
			 (let ((new-array (copy-array omega)))
			   (funcall (make-rotator) new-array)
			   new-array)
			 (if (arrayp omega)
			     (apply-marginal (make-rotator)
					     omega axis (1- (rank omega)))))))
		 (lambda (omega alpha &optional axes)
		   (let ((alpha (disclose alpha))
			 (axis (- (if axes (aref (first axes) 0)
				      (rank omega))
				  index-origin))
			 (dims (dims omega)))
		     (if (vectorp omega)
			 (let ((new-array (copy-array omega)))
			   (if (not (integerp alpha))
			       (error (concatenate 'string "The left argument to ⌽ must be a single integer, "
						   "i.e. 2⌽⍳10, if the right argument is a vector."))
			       (funcall (make-rotator alpha) new-array))
			   new-array)
			 (progn (if (not (arrayp alpha))
				    (setq alpha (make-array (loop :for d :from 0 :to (1- (rank omega))
							       :when (not (= d axis))
							       :collect (nth d dims))
							    :initial-element alpha)))
				(vector-subprocess omega alpha axis (lambda (item arg)
								      (funcall (make-rotator arg) item))))))))
     (tests (is "⌽1 2 3 4 5" #(5 4 3 2 1))
	    (is "⌽3 4⍴⍳9" #2A((4 3 2 1) (8 7 6 5) (3 2 1 9)))
	    (is "2⌽3 4⍴⍳9" #2A((3 4 1 2) (7 8 5 6) (2 3 9 1)))
	    (is "(2 2⍴1 2 3 4)⌽2 2 5⍴⍳9" #3A(((2 3 4 5 1) (8 9 1 6 7)) ((5 6 2 3 4) (2 7 8 9 1))))))
  (⊖ (has :titles ("Reverse First" "Rotate First"))
     (ambivalent (lambda (omega &optional axes)
		   (let ((axis (if axes (- (aref (first axes) 0)
					   index-origin)
				   0)))
		     (if (vectorp omega)
			 (let ((new-array (copy-array omega)))
			   (funcall (make-rotator) new-array)
			   new-array)
			 (if (arrayp omega)
			     (apply-marginal (make-rotator)
					     omega axis (1- (rank omega)))))))
		 (lambda (omega alpha &optional axes)
		   (let ((alpha (disclose alpha))
			 (axis (if axes (- (aref (first axes) 0)
					   index-origin)
				   0))
			 (dims (dims omega)))
		     (if (vectorp omega)
			 (let ((new-array (copy-array omega)))
			   (if (not (integerp alpha))
			       (error (concatenate 'string "The left argument to ⊖ must be a single integer, "
						   "i.e. 2⊖⍳10, if the right argument is a vector."))
			       (funcall (make-rotator alpha) new-array))
			   new-array)
			 (progn (if (not (arrayp alpha))
				    (setq alpha (make-array (loop :for d :from 0 :to (1- (rank omega))
							       :when (not (= d axis))
							       :collect (nth d dims))
							    :initial-element alpha)))
				(vector-subprocess omega alpha axis (lambda (item arg)
								      (funcall (make-rotator arg) item))))))))
     (tests (is "⊖1 2 3 4 5" #(5 4 3 2 1))
	    (is "⊖3 4⍴⍳9" #2A((9 1 2 3) (5 6 7 8) (1 2 3 4)))
	    (is "1⊖3 4⍴⍳9" #2a((5 6 7 8) (9 1 2 3) (1 2 3 4)))))
  (⍉ (has :titles ("Transpose" "Permute"))
     (ambivalent (lambda (omega)
		   (aops:permute (reverse (alexandria:iota (rank omega)))
				 omega))
		 (lambda (omega alpha)
		   (aops:permute (mapcar (lambda (i) (- i index-origin))
					 (array-to-list alpha))
				 omega)))
     (tests (is "⍉2 3 4⍴⍳9" #3A(((1 4) (5 8) (9 3)) ((2 5) (6 9) (1 4))
				((3 6) (7 1) (2 5)) ((4 7) (8 2) (3 6))))
	    (is "1 3 2⍉2 3 4⍴⍳9" #3A(((1 5 9) (2 6 1) (3 7 2) (4 8 3))
				     ((4 8 3) (5 9 4) (6 1 5) (7 2 6))))))
  (⌹ (has :titles ("Matrix Inverse" "Matrix Divide"))
     (ambivalent (lambda (omega)
		   (if (and (= 1 (rank omega))
			    (= 1 (length omega)))
		       (/ (disclose omega))
		       (if (< 2 (rank omega))
			   (error "Matrix inversion only works on arrays of rank 2 or 1.")
			   (if (let ((odims (dims omega)))
				 (and (= 2 (length odims))
				      (= (first odims) (second odims))))
			       (invert-matrix omega)
			       (left-invert-matrix omega)))))
		 (lambda (omega alpha)
		   (array-inner-product (invert-matrix omega)
					alpha (lambda (arg1 arg2)
						(apply-scalar-dyadic #'* arg1 arg2))
					#'+)))
     (tests (is "⌹1 2 3 4" #(1/30 1/15 1/10 2/15))
	    (is "⌹2 2⍴4 9 8 2" #2A((-1/32 9/64) (1/8 -1/16)))
	    (is "⌹4 2⍴1 3 ¯4 9" #2A((3/14 -1/14 3/14 -1/14) (2/21 1/42 2/21 1/42)))
	    (is "35 89 79⌹3 3⍴3 1 4 1 5 9 2 6 5" #(193/90 739/90 229/45))
	    (is "(3 2⍴1 2 3 6 9 10)⌹3 3⍴1 0 0 1 1 0 1 1 1" #2A((1 2) (2 4) (6 4)))))
  (⍋ (has :titles ("Grade Up" "Grade Up By"))
     (ambivalent (lambda (omega) (grade omega (alpha-compare atomic-vector #'<=)
					index-origin))
		 (lambda (omega alpha) (grade (if (vectorp alpha)
						  (index-of alpha omega index-origin)
						  (array-grade alpha omega))
					      (alpha-compare atomic-vector #'<)
					      index-origin)))
     (tests (is "⍋8 3 4 9 1 5 2" #(5 7 2 3 6 1 4))
	    (is "⍋5 6⍴⍳16" #(1 4 2 5 3))
	    (is "st←'aodjeignwug' ⋄ st[⍋st]" "adeggijnouw")
	    (is "(2 5⍴'ABCDEabcde')⍋'ACaEed'" #(1 3 2 6 4 5))))
  (⍒ (has :titles ("Grade Down" "Grade Down By"))
     (ambivalent (lambda (omega) (grade omega (alpha-compare atomic-vector #'>=)
					index-origin))
		 (lambda (omega alpha) (grade (if (vectorp alpha)
						  (index-of alpha omega index-origin)
						  (array-grade alpha omega))
					      (alpha-compare atomic-vector #'>)
					      index-origin)))
     (tests (is "⍒6 1 8 2 4 3 9" #(7 3 1 5 6 4 2))
	    (is "⍒5 6⍴⍳12" #(2 4 1 3 5))
	    (is "st←'aodjeignwug' ⋄ st[⍒st]" "wuonjiggeda")
	    (is "(2 5⍴'ABCDEabcde')⍒'ACaEed'" #(5 4 6 2 3 1))))
  (⊤ (has :title "Encode")
     (dyadic (lambda (omega alpha)
	       (flet ((rebase (bases number)
			(let ((operand number)
			      (last-base 1)
			      (base 1)
			      (component 1)
			      (element nil))
			  (loop :for index :from (1- (length bases)) :downto 0
			     :do (setq last-base base
				       base (* base (aref bases index))
				       component (if (= 0 base)
						     operand (* base (nth-value 1 (floor (/ operand base)))))
				       operand (- operand component)
				       element (/ component last-base))
			     :collect element))))
		 (if (= 1 (length omega))
		     (let ((result (rebase alpha (aref omega 0))))
		       (make-array (list (length result))
				   :initial-contents (reverse result)))
		     (aops:permute (list 1 0)
				   (make-array (list (length omega) (length alpha))
					       :initial-contents
					       (mapcar (lambda (item) (reverse (rebase alpha item)))
						       (array-to-list omega))))))))
     (tests (is "1760 3 12⊤82" #(2 0 10))
	    (is "16 16 16 16⊤100" #(0 0 6 4))
	    (is "2 2 2 2 2⊤1 2 3 4 5" #2A((0 0 0 0 0) (0 0 0 0 0) (0 0 0 1 1)
					  (0 1 1 0 0) (1 0 1 0 1)))))
  (⊥ (has :title "Decode")
     (dyadic (lambda (omega alpha)
	       (flet ((rebase (bases numerators)
			(let ((result 0)
			      (base 1))
			  (loop :for index :from (1- (length numerators)) :downto 0
			     :do (incf result (* base (aref numerators index)))
			     (setf base (* base (aref bases index))))
			  result)))
		 (let ((bases (if (= 1 (length alpha))
				  (make-array (list (first (dims omega)))
					      :initial-element (aref alpha 0))
				  (if (not (= (length alpha)
					      (let ((d-o (dims omega)))
						(if (= 1 (length d-o))
						    (first d-o)
						    (second d-o)))))
				      (error "Base/element length mismatch.")
				      alpha))))
		   (if (= 1 (rank omega))
		       (vector (rebase bases omega))
		       (aops:margin (lambda (sub-array) (rebase bases sub-array))
				    omega 0))))))
     (tests (is "10⊥2 6 7 1" 2671)
	    (is "1760 3 12⊥2 2 5" 101)
	    (is "1760 3 12⊥3 3⍴1 2 1 5 0 2 2 3 7" #(98 75 67))))
  ;; (⍎ (has :title "Evaluate")
  ;;    (monadic (macro (lambda (meta axes omega)
  ;; 			 (declare (ignore meta axes))
  ;; 			 `(april ,omega))))
  ;;    (tests (is "⍎'1+1'" 2)))
  (∘ (has :title "Find Outer Product, Not Inner")
     (symbolic :outer-product-designator)))

 (operators
  ;; (← (has :title "Assign Result Of")
  ;;    (lateral (lambda (meta axes right-function)
  ;; 		  (declare (ignore meta axes))
  ;; 		  (lambda (meta unused omega alpha)
  ;; 		    (declare (ignore unused))
  ;; 		    (if (and (listp alpha)
  ;; 			     (eql 'aref-eliding (first alpha)))
  ;; 			(append alpha (list :set `(lambda (item coords)
  ;; 						    (declare (ignore coords))
  ;; 						    (funcall (lambda (omega alpha)
  ;; 							       ,(funcall right-function
  ;; 									 meta nil 'omega 'alpha))
  ;; 							     ,omega item))))
  ;; 			(let ((symbol (if (listp alpha)
  ;; 					  (second alpha)
  ;; 					  alpha)))
  ;; 			  `(setq ,symbol (funcall (lambda (omega alpha)
  ;; 						    ,(funcall right-function meta nil 'omega 'alpha))
  ;; 						  ,omega ,alpha)))))))
  ;;    (tests (is "a←3 2 1 ⋄ a+←5 ⋄ a" #(8 7 6))
  ;; 	      (is "a←3 2 1 ⋄ a[2]+←5 ⋄ a" #(3 7 1))))
  (/ (has :title "Reduce")
     (lateral (lambda (function workspace axes)
		(declare (ignore workspace))
		(over-operator-template axes (if (not (characterp function))
						 function (get-function-data (local-idiom april)
									     function :dyadic))
					:for-vector '(lambda (function input)
						      (vector (reduce function input)))
					:for-array '(lambda (function input axis)
						     (aops:margin (lambda (s) (reduce function s))
						      input axis)))))
     (tests (is "+/1 2 3 4 5" 15)
	    (is "+/3 4⍴⍳12" #(10 26 42))
	    (is "+/[1]3 4⍴⍳12" #(15 18 21 24))
	    (is "fn←{⍺+⍵} ⋄ fn/1 2 3 4 5" 15)
	    (is "⌊10000×{⍺+÷⍵}/40/1" 16180)))
  (⌿ (has :title "Reduce First")
     (lateral (lambda (function workspace axes)
		(declare (ignore workspace))
		(over-operator-template axes (if (not (characterp function))
						 function (get-function-data (local-idiom april)
									     function :dyadic))
					:first-axis t
					:for-vector '(lambda (function input)
						      (vector (reduce function input)))
					:for-array '(lambda (function input axis)
						     (aops:margin (lambda (s) (disclose (reduce function s)))
						      input axis)))))
     (tests (is "+⌿3 4⍴⍳12" #(15 18 21 24))
	    (is "{⍺×⍵+3}⌿3 4⍴⍳12" #(207 330 495 708))
	    (is "+⌿[2]3 4⍴⍳12" #(10 26 42))))
  (\\ (has :title "Scan")
      (lateral (lambda (function workspace axes)
		 (declare (ignore workspace))
		 (over-operator-template axes (if (not (characterp function))
						  function (get-function-data (local-idiom april)
									      function :dyadic))
					 :for-vector '(lambda (function input)
						       (funcall (make-back-scanner function)
							input))
					 :for-array '(lambda (function input axis)
						      (apply-marginal (make-back-scanner function)
						       input axis (1- (rank input)))))))
      (tests (is "+\\1 2 3 4 5" #(1 3 6 10 15))
	     (is "+\\3 4⍴⍳12" #2A((1 3 6 10) (5 11 18 26) (9 19 30 42)))
	     (is "+\\[1]3 4⍴⍳12" #2A((1 2 3 4) (6 8 10 12) (15 18 21 24)))))
  (⍀ (has :title "Scan First")
     (lateral (lambda (function workspace axes)
		(declare (ignore workspace))
		(over-operator-template axes (if (not (characterp function))
						 function (get-function-data (local-idiom april)
									     function :dyadic))
					:first-axis t
					:for-vector '(lambda (function input)
						      (funcall (make-back-scanner function)
						       input))
					:for-array '(lambda (function input axis)
						     (apply-marginal (make-back-scanner function)
						      input axis (1- (rank input)))))))
     (tests (is "+⍀1 2 3 4 5" #(1 3 6 10 15))
	    (is "+⍀3 4⍴⍳12" #2A((1 2 3 4) (6 8 10 12) (15 18 21 24)))
	    (is "{⍺×⍵+3}⍀3 4⍴⍳12" #2A((1 2 3 4) (20 30 42 56) (288 450 660 924)))
	    (is "+⍀[2]3 4⍴⍳12" #2A((1 3 6 10) (5 11 18 26) (9 19 30 42)))))
  (\¨ (has :title "Each")
      (lateral (lambda (operand workspace axes)
		 (declare (ignore workspace axes))
		 (let ((operation-monadic (if (not (characterp operand))
					      operand (get-function-data (local-idiom april) operand :monadic)))
		       (operation-dyadic (if (not (characterp operand))
					     operand (get-function-data (local-idiom april) operand :dyadic)))
		       (index (gensym)))
		   `(lambda (omega &optional alpha)
		      (if alpha
			  (make-array (dims alpha)
				      :initial-contents
				      (loop :for ,index :from 0 :to (1- (length alpha))
					 :collect (disclose (apl-call ,operation-dyadic (aref omega 0)
								      (aref alpha ,index)))))
			  (aops:each (lambda (item) (disclose (apl-call ,operation-monadic item)))
				     omega))))))
      (tests (is "⍳¨1 2 3" #(1 #(1 2) #(1 2 3)))
	     (is "1 ¯1⌽¨⊂1 2 3 4 5" #(#(2 3 4 5 1) #(5 1 2 3 4)))))
  (⍨ (has :title "Commute")
     (lateral (lambda (operand workspace axes)
		(declare (ignore workspace axes))
		`(lambda (omega &optional alpha)
		   (apl-call ,(if (not (characterp operand))
				  operand (get-function-data (local-idiom april) operand :dyadic))
			     (if alpha alpha omega)
			     omega))))
     (tests (is "5-⍨10" 5)
	    (is "+⍨10" 20)))
  (\. (has :title "Inner/Outer Product")
      (pivotal (lambda (right left workspace)
		 (declare (ignore workspace))
		 (let ((op-right `(lambda (alpha omega)
				    (apl-call ,(if (not (characterp right))
						   right (get-function-data (local-idiom april)
									    right :dyadic))
					      omega alpha)))
		       (op-left (let ((left-op (if (not (characterp left))
						   left (or (get-function-data (local-idiom april)
									       left :symbolic)
							    (get-function-data (local-idiom april)
									       left :dyadic)))))
				  (if (not (eq :outer-product-designator left-op))
				      `(lambda (alpha omega) (apl-call ,left-op omega alpha))
				      left-op))))
		   (if (eq :outer-product-designator op-left)
		       `(lambda (omega alpha)
			  (if (is-unitary omega)
			      (aops:each (lambda (element)
					   (let ((alpha element)
						 (omega (disclose omega)))
					     (disclose (apl-call ,op-right alpha omega))))
					 alpha)
			      (let ((inverse (aops:outer (lambda (omega alpha)
							   (let ((omega (enclose omega))
								 (alpha (enclose alpha)))
							     (if (is-unitary omega)
								 ;; swap arguments in case of a
								 ;; singleton omega argument
								 (let ((placeholder alpha))
								   (setq alpha omega
									 omega placeholder)))
							     (disclose (apl-call ,op-right alpha omega))))
							 alpha omega)))
				(if (not (is-unitary alpha))
				    inverse (aops:permute (reverse (alexandria:iota (rank inverse)))
							  inverse)))))
		       `(lambda (omega alpha)
			  (if (and (vectorp omega)
				   (vectorp alpha))
			      (make-array (list 1)
					  :initial-element
					  (reduce ,op-left (apply-scalar-dyadic ,op-right alpha omega)))
			      (array-inner-product alpha omega (lambda (arg1 arg2)
								 (if (or (arrayp arg1)
									 (arrayp arg2))
								     (apply-scalar-dyadic ,op-right arg1 arg2)
								     (funcall ,op-right arg1 arg2)))
						   ,op-left)))))))
      (tests (is "2+.×3 4 5" 24)
	     (is "2 3 4+.×8 15 21" 145)
	     (is "2 3 4+.×3 3⍴3 1 4 1 5 9 2 6 5" #(17 41 55))
	     (is "(3 3⍴3 1 4 1 5 9 2 6 5)+.×2 3 4" #(25 53 42))
	     (is "4 5 6∘.+20 30 40 50" #2A((24 34 44 54) (25 35 45 55) (26 36 46 56)))
	     (is "1 2 3∘.-1 2 3" #2A((0 -1 -2) (1 0 -1) (2 1 0)))
	     (is "1 2 3∘.⍴1 2 3" #2A((1 2 3) (#(1 1) #(2 2) #(3 3)) (#(1 1 1) #(2 2 2) #(3 3 3))))
	     (is "1 2 3∘.⍴⊂1 2 3" #(1 #(1 2) #(1 2 3)))
	     (is "1 2 3∘.⌽⊂1 2 3" #(#(2 3 1) #(3 1 2) #(1 2 3)))
	     (is "1 2 3∘.⌽[1]⊂4 5 6 7" #(#(5 6 7 4) #(6 7 4 5) #(7 4 5 6)))))
  (∘ (has :title "Compose")
     (pivotal (lambda (right left workspace)
		(declare (ignore workspace))
		(flet ((is-fn (item)
			 (or (characterp item)
			     (and (listp item)
				  (eql 'lambda (first item))))))
		  `(lambda (omega &optional alpha)
		     (declare (ignorable alpha))
		     ,(if (and (is-fn right)
			       (is-fn left))
			  `(let ((processed (apl-call ,(if (not (characterp right))
							   right (get-function-data
								  (local-idiom april)
								  right :monadic))
						      omega)))
			     (if alpha ,@(loop :for type :in (list :dyadic :monadic)
					    :collect `(apl-call ,(if (not (characterp left))
								     left (get-function-data
									   (local-idiom april)
									   left type))
								processed ,@(if (eq :dyadic type)
										(list 'alpha))))))
			  `(apl-call ,(get-function-data (local-idiom april)
							 (if (is-fn right) right left)
							 :dyadic)
				     ,(if (not (is-fn right))
					  right 'omega)
				     ,(if (not (is-fn left))
					  left 'omega)))))))
     (tests (is "fn←⍴∘⍴ ⋄ fn 2 3 4⍴⍳9" 3)
	    (is "⍴∘⍴ 2 3 4⍴⍳9" 3)
	    (is "⍴∘⍴∘⍴ 2 3 4⍴⍳9" 1)
	    (is "÷∘5 ⊢30" 6)
	    (is "⌊10000×(+∘*∘0.5) 4 16 25" #(56487 176487 266487))
	    (is "fn←5∘- ⋄ fn 2" 3)
	    (is "⌊0.5∘+∘* ⊢5 8 12" #(148 2981 162755))
	    (is "⌊10000×+∘÷/40/1" 16180)
	    (is "+/∘⍳¨2 5 8" #(3 15 36))))
  (⍤ (has :title "Rank")
     (pivotal (lambda (right left workspace)
		(declare (ignore workspace))
		(let ((at-omega (second right)))
		  `(lambda (omega &optional alpha)
		     (let ((orank (rank omega))
			   (fn (if alpha
				   (lambda (omega alpha) (apl-call ,(if (not (characterp left))
									left (get-function-data (local-idiom april)
												left :dyadic))
								   omega alpha))
				   (lambda (omega) (apl-call ,(if (not (characterp left))
								  left (get-function-data (local-idiom april)
											  left :monadic))
							     omega)))))
		       (if (= orank ,at-omega)
			   (vector (if alpha (funcall fn omega alpha)
				       (funcall fn omega)))
			   (let ((encr (make-array (list ,at-omega)
						   :initial-contents
						   (iota ,at-omega :start (- orank (1- ,at-omega)
									     index-origin)))))
			     (mix-arrays 0 (aops:each (lambda (item) (vector (funcall fn item)))
						      (re-enclose omega encr))
					 :disclose-items t))))))))
     (tests (is "⊂⍤2 ⊢2 3 4⍴⍳9" #(#2A((1 2 3 4) (5 6 7 8) (9 1 2 3))
				  #2A((4 5 6 7) (8 9 1 2) (3 4 5 6))))))
  (⍣ (has :title "Power")
     (pivotal (lambda (right left workspace)
		(declare (ignore workspace))
		(let ((op-right (if (not (characterp right))
				    right (get-function-data (local-idiom april)
							     right :monadic)))
		      (op-left (if (not (characterp left))
				   left (get-function-data (local-idiom april)
							   left :monadic))))
		  (cond ((and (listp op-right)
			      (not (eql 'lambda (first op-right))))
			 (let ((arg (gensym))
			       (index (gensym)))
			   `(lambda (omega &optional alpha)
			      (declare (ignorable alpha))
			      (let ((,arg (disclose omega)))
				(loop :for ,index :from 0 :to (1- (disclose ,op-right))
				   :do (setq ,arg (enclose (apl-call ,op-left ,arg))))
				,arg))))
			((listp op-right)
			 (let ((arg (gensym))
			       (prior-arg (gensym)))
			   `(lambda (omega &optional alpha)
			      (declare (ignorable alpha))
			      (let ((,arg omega)
				    (,prior-arg omega))
				(loop :while (= 0 (disclose (apl-call ,op-right ,prior-arg ,arg)))
				   :do (setq ,prior-arg ,arg
					     ,arg (enclose (apl-call ,op-left ,arg))))
				,arg))))))))
     (tests (is "fn←{2+⍵}⍣3 ⋄ fn 5" 11)
	    (is "({2+⍵}⍣3) 9" 15)
	    (is "fn←{2+⍵}⍣{10<⍺} ⋄ fn 2" 12)
	    (is "fn←{2+⍵}⍣{10<⍵} ⋄ fn 2" 14)))
  (@ (has :title "At")
     (pivotal (lambda (right left workspace)
		(declare (ignore workspace))
		(let* ((index (gensym)) (new-array (gensym)) (mask (gensym)) (alpha-var (gensym))
		       (omega-var (gensym)) (aix (gensym)) (ix (gensym))
		       (item (gensym)) (coords (gensym)))
		  (cond ((or (characterp right)
			     (eql 'lambda (first right)))
			 `(lambda (omega)
			    (run-dim omega (lambda (,item ,coords)
					     (if (/= 0 (disclose (apl-call ,right ,item)))
						 (setf (apply #'aref (cons omega ,coords))
						       (disclose
							,(cond ((characterp left)
								`(apl-call ,(get-function-data (local-idiom april)
											       left :monadic)
									   ,item))
							       ((eql 'lambda (first left))
								`(apl-call ,left ,item))
							       (t left))))
						 ,item)))
			    omega))
			(t `(lambda (omega)
			      (let* ((,omega-var (apply-scalar-dyadic #'- ,right index-origin))
				     (coord nil))
				(loop :for ,index :from 0 :to (1- (length ,omega-var))
				   :do (setq coord (aref ,omega-var ,index))
				   (aref-eliding omega (if (arrayp coord)
							   (mapcar #'list (array-to-list coord))
							   (list (list coord)))
						 :set ,@(cond ((characterp left)
							       (list (get-function-data (local-idiom april)
											left :monadic)))
							      ((eql 'lambda (first left))
							       (list left))
							      (t `((if (is-unitary ,left)
								       (disclose ,left)
								       ;; (aref ,left ,index)
								       (lambda (item ,coords)
									 (declare (ignore item))
									 (let ((alen (if (not (listp coord))
											 1 (length coord))))
									   (aref-eliding
									    ,left
									    (mapcar #'list
										    (append (list ,index)
											    (nthcdr alen
												    ,coords)))))))
								   :set-coords t)))))
				omega)))))))
     (tests (is "(20 20@3 8) ⍳9" #(1 2 20 4 5 6 7 20 9))
  	      (is "((2 5⍴0 1)@2 5) 5 5⍴⍳9" #2A((1 2 3 4 5) (0 1 0 1 0) (2 3 4 5 6)
  					       (7 8 9 1 2) (1 0 1 0 1)))
  	      (is "(0@(3∘|)) ⍳9" #(0 0 3 0 0 6 0 0 9))
  	      (is "(÷@3 5) ⍳9" #(1 2 1/3 4 1/5 6 7 8 9))
  	      (is "({⍵×2}@{⍵>3}) ⍳9" #(1 2 3 8 10 12 14 16 18)))))

 (general-tests (with :title "Basic function definition and use, with comments."
 		      :in ("⍝ This code starts with a comment.
    f1←{⍵+3} ⋄ f2←{⍵×2} ⍝ A comment after the functions are defined.
    ⍝ This is another comment.
    f2 f1 1 2 3 4 5")
 		      :ex #(8 10 12 14 16))
 		(with :title "Monadic inline function."
 		      :in ("{⍵+3} 3 4 5")
 		      :ex #(6 7 8))
 		(with :title "Dyadic inline function."
 		      :in ("1 2 3 {⍺×⍵+3} 3 4 5")
 		      :ex #(6 14 24))
		(with :title "Vector of input variables and discrete values processed within a function."
		      :in ("fn←{3+⍵} ⋄ {fn 8 ⍵} 9")
		      :ex #(11 12))
 		(with :title "Variable-referenced values, including an element within an array, in a vector."
 		      :in ("a←9 ⋄ b←2 3 4⍴⍳9 ⋄ 1 2 a 3 b[1;2;1]")
 		      :ex #(1 2 9 3 5))
		(with :title "Application of functions to indexed array elements."
		      :in ("g←2 3 4 5 ⋄ 9,g[2],3 4")
		      :ex #(9 3 3 4))
 		(with :title "Assignment of an element within an array."
 		      :in ("a←2 3⍴⍳9 ⋄ a[1;2]←20 ⋄ a")
 		      :ex #2A((1 20 3) (4 5 6)))
 		(with :title "Selection from an array with multiple elided dimensions."
 		      :in ("(2 3 3 4 5⍴⍳9)[2;;3;;2]")
 		      :ex #2A((6 2 7 3) (3 8 4 9) (9 5 1 6)))
 		(with :title "Elided assignment."
 		      :in ("a←2 3 4⍴⍳9 ⋄ a[2;;3]←0 ⋄ a")
 		      :ex #3A(((1 2 3 4) (5 6 7 8) (9 1 2 3)) ((4 5 0 7) (8 9 0 2) (3 4 0 6))))
 		;; (with :title "Elided assignment of applied function's results."
 		;;       :in ("a←2 3 4⍴⍳9 ⋄ a[2;;3]+←10 ⋄ a")
 		;;       :ex #3A(((1 2 3 4) (5 6 7 8) (9 1 2 3)) ((4 5 16 7) (8 9 11 2) (3 4 15 6))))
		(with :title "Elision and indexed array elements."
		      :in ("(6 8⍴⍳9)[1 4;]")
		      :ex #2A((1 2 3 4 5 6 7 8) (7 8 9 1 2 3 4 5)))
		(with :title "As above but more complex."
		      :in ("(6 8 5⍴⍳9)[1 4;;2 1]")
		      :ex #3A(((2 1) (7 6) (3 2) (8 7) (4 3) (9 8) (5 4) (1 9))
			      ((5 4) (1 9) (6 5) (2 1) (7 6) (3 2) (8 7) (4 3))))
		(with :title "Indices of indices."
		      :in ("(6 8 5⍴⍳9)[1 4;;2 1][1;2 4 5;]")
		     :ex #2A((7 6) (8 7) (4 3)))
		;; (with :title "Operation over portions of an array."
		;;       :in ("a←4 8⍴⍳9 ⋄ a[2 4;1 6 7 8]+←10 ⋄ a")
		;;       :ex #2A((1 2 3 4 5 6 7 8) (19 1 2 3 4 15 16 17)
		;; 	      (8 9 1 2 3 4 5 6) (17 8 9 1 2 13 14 15)))
		))
