 ;;;; april.lisp

(in-package #:april)

(defun array-to-nested-vector (array)
  "Convert an array to a nested vector. Useful for applications such as JSON conversion where multidimensional arrays must be converted to nested vectors."
  (aops:each (lambda (member)
	       (if (and (arrayp member)
			(< 1 (rank member)))
		   (array-to-nested-vector member)
		   member))
	     (aops:split array 1)))

(defun is-singleton (value)
  "Determine whether an array is a singleton, possessing just one member."
  (or (and (atom value)
	   (not (arrayp value)))
      ;; non-array atoms are considered singleton values
      (let ((adims (dims value)))
	(and (= 1 (first adims))
	     (= 1 (length adims))))))

(defun apply-scalar-monadic (function omega)
  "Apply a scalar function across a single arguments, iterating over multidimensional and nested arrays."
  (labels ((apply-fn (arg) (if (arrayp arg)
			       (aops:each #'apply-fn arg)
			       (funcall function arg))))
    (aops:each #'apply-fn omega)))

(defmacro normalizing-vector (&rest items)
  (cons 'vector (loop for item in items
		   collect (if (and (listp item)
				    (eql 'disclose-within-vector (first item)))
			       `(disclose ,item)
			       item))))

(defmacro disclose-within-vector (item)
  item)

(defun apply-scalar-dyadic (function alpha omega)
  "Apply a scalar function across objects as appropriate in APL. Handles scalars as well as nested and multidimensional arrays."
  (let* ((alpha-scalar? (not (arrayp alpha)))
	 (omega-scalar? (not (arrayp omega)))
	 (alpha-unitary? (and (not alpha-scalar?)
			      (vectorp alpha)
			      (= 1 (length alpha))))
	 (omega-unitary? (and (not omega-scalar?)
			      (vectorp omega)
			      (= 1 (length omega)))))
    (cond ((and alpha-scalar? omega-scalar?)
	   (funcall function alpha omega))
	  ((and alpha-scalar? omega-unitary?)
	   (aops:each (lambda (alpha omega) (apply-scalar-dyadic function alpha omega))
		      (vector alpha)
		      omega))
	  ((and alpha-unitary? omega-scalar?)
	   (aops:each (lambda (alpha omega) (apply-scalar-dyadic function alpha omega))
		      alpha (vector omega)))
	  ((and alpha-unitary? omega-unitary?)
	   (aops:each (lambda (alpha omega) (apply-scalar-dyadic function alpha omega))
		      alpha omega))
	  ((and (not alpha-unitary?)
		(not omega-unitary?)
		(not alpha-scalar?)
		(not omega-scalar?))
	   (if (loop for dimension in (funcall (lambda (a o) (mapcar #'= a o))
					       (dims alpha)
					       (dims omega))
		  always dimension)
	       (aops:each (lambda (alpha omega) (apply-scalar-dyadic function alpha omega))
			  alpha omega)
	       (error "Array size mismatch.")))
	  (t (labels ((scan-over (element)
			(if (arrayp element)
			    (aops:each #'scan-over element)
			    (apply (lambda (left right) (apply-scalar-dyadic function left right))
				   (cond (alpha-scalar? (list alpha element))
					 (alpha-unitary? (list (aref alpha 0)
							       element))
					 (omega-scalar? (list element omega))
					 (omega-unitary? (list element (aref omega 0))))))))
	       (aops:each #'scan-over (if (or alpha-scalar? alpha-unitary?)
					  omega alpha)))))))

(defmacro mediate-operation (operation)
  "Process the spec for a function or operator, building a function to process its arguments and generate code to run the operation."
  (flet ((mediate-arguments (operation arg-specs omega-sym &optional alpha-sym)
	   ;; moderate arguments to a Vex function at compile time
	   (let* ((fn (if (and (listp operation)
			       (macro-function (first operation))
			       (not (eql 'lambda (first operation))))
			  `(quote ,(macroexpand (append operation (if (second arg-specs)
								      (list omega-sym alpha-sym)
								      (list omega-sym)))))
			  `(quote (function ,operation)))))
	     (if (eq :scalar (first arg-specs))
		 ;; for a scalar function, return both monadic and dyadic variants if applicable
		 (if (eq :dyadic (second arg-specs))
		     ``(funcall #'apply-scalar-dyadic ,,fn ,(macroexpand ,omega-sym)
				,(macroexpand ,alpha-sym))
		     ``(funcall #'apply-scalar-monadic ,,fn ,(macroexpand ,omega-sym)))
		 ;; assign the alpha, omega and axis argument specs
		 (let ((alpha (if (not (eq :axes (second arg-specs)))
				  (second arg-specs)))
		       (omega (first arg-specs))
		       (axes (if (eq :axes (second arg-specs))
				 (second arg-specs)
				 (third arg-specs))))
		   ``(if (and ,,@(cond ((eq :one alpha)
					`(`(is-singleton ,(macroexpand ,alpha-sym))))
				       ((eq :sym omega)
					`(`(symbolp (quote ,(if (listp (macroexpand ,omega-sym))
								(second (getf (macroexpand ,omega-sym)
									      :initial-contents))
								(macroexpand ,omega-sym)))))))
			      ,,@(if (and alpha (not (eq :any alpha)))
				     (if (eq :one omega)
					 `(`(is-singleton ,(macroexpand ,omega-sym))))))
			 ;; if the arguments are scalar (:one), remove them from their arrays for evaluation
			 (funcall ,,fn
				  ,,(cond ((eq :one omega)
					   ``(if (arrayp ,(macroexpand ,omega-sym))
						 (disclose ,(macroexpand ,omega-sym))
						 ,(macroexpand ,omega-sym)))
					  ((eq :sym omega)
					   ``(quote ,(if (listp (macroexpand ,omega-sym))
							 (second (getf (macroexpand ,omega-sym)
								       :initial-contents))
							 (macroexpand ,omega-sym))))
					  (t `(macroexpand ,omega-sym)))
				  ,,@(if alpha (list (cond ((eq :one alpha)
							    ``(disclose ,(macroexpand ,alpha-sym)))
							   ((eq :axes alpha)
							    (cons 'list (macroexpand axes)))
							   ;; alpha is equal to :axes when
							   ;; axes are used for a monadic function
							   (t `(macroexpand ,alpha-sym)))))
				  ,,@(if axes (list ``(list ,@(macroexpand axes)))))))))))
    (let* ((operation-name (intern (string-upcase (first operation))
				   "KEYWORD"))
	   (alpha-sym (intern "ALPHA"))
	   (omega-sym (intern "OMEGA"))
	   (valencies (rest operation))
	   (mediated (if (or (eq :symmetric-scalar (first valencies))
			     (eq :asymmetric-scalar (first valencies)))
			 (list (mediate-arguments (if (third valencies)
						      (third valencies)
						      (second valencies))
						  (list :scalar :dyadic)
						  omega-sym alpha-sym)
			       (mediate-arguments (second valencies)
						  (list :scalar :monadic)
						  omega-sym))
			 (append (if (second valencies)
				     (list (mediate-arguments (first (last (second valencies)))
							      (butlast (rest (second valencies)))
							      omega-sym alpha-sym)))
				 (let ((arg-specs (butlast (rest (first valencies)))))
				   (list (apply #'mediate-arguments
						(append (list (first (last (first valencies))))
							(list (append arg-specs
								      (if (and (eq :scalar (first arg-specs))
									       (eq :dyadic operation-name))
									  (list :dyadic)))
							      omega-sym)
							(if (eq :dyadic operation-name)
							    (list alpha-sym))))))))))
      `(lambda (meta axes omega &optional alpha)
	 (declare (ignorable meta axes alpha))
	 ,(cond ((eq :monadic operation-name)
		 `(if alpha
		      `(progn (error "Valence error - monadic operation."))
		      ,(first mediated)))
		((eq :dyadic operation-name)
		 `(if alpha
		      ,(first mediated)
		      `(error "Valence error - dyadic operation.")))
		((eq :ambivalent operation-name)
		 `(if alpha ,@mediated)))))))

(defun numeric-string-p (string)
  "Checks whether the argument is a numeric string."
  (handler-case (progn (parse-apl-number-string string) t)
    (condition () nil)))

(defun parse-apl-number-string (number-string &optional imaginary-component)
  "Parse an APL numeric string into a Lisp value, handling high minus signs and the J-notation for complex numbers."
  (let ((nstring (string-upcase number-string)))
    (if (and (not imaginary-component)
	     (find #\J nstring))
	(let ((halves (cl-ppcre:split "J" nstring)))
	  (if (and (= 2 (length halves))
		   (< 0 (length (first halves)))
		   (< 0 (length (second halves))))
	      (complex (parse-apl-number-string (first halves) t)
		       (parse-apl-number-string (second halves) t))))
	;; either the macron or combining_macron character may be used as the high minus sign
	(parse-number:parse-number (regex-replace-all "[¯̄]" nstring "-")))))

(defun format-value (idiom-name meta element)
  "Convert a token string into an APL value, paying heed to APL's native ⍺, ⍵ and ⍬ variables."
  (cond ((and (vectorp element)
	      (string= element "⍬"))
	 ;; APL's "zilde" character translates to an empty vector
 	 (make-array (list 0)))
	((and (vectorp element)
	      (or (string= element "⍺")
		  (string= element "⍵")))
	 ;; alpha and omega characters are directly changed to symbols
 	 (intern element idiom-name))
	((numeric-string-p element)
	 (parse-apl-number-string element))
	((or (and (char= #\" (aref element 0))
		  (char= #\" (aref element (1- (length element)))))
	     (and (char= #\' (aref element 0))
		  (char= #\' (aref element (1- (length element))))))
	 ;; strings are converted to Lisp strings and passed through
	 (subseq element 1 (1- (length element))))
	((stringp element)
	 ;; variable references are converted into generated symbols from the variable table or,
	 ;; if no reference is found in that table, a new reference is created there and a new symbol
	 ;; is generated
	 (if (not (gethash :variables meta))
	     (setf (gethash :variables meta)
		   (make-hash-table :test #'eq)))
	 (let ((variable-found (gethash (intern element "KEYWORD")
					(gethash :variables meta))))
	   (if variable-found variable-found
	       ;; create a new variable if no variable is found matching the string
	       (setf (gethash (intern element "KEYWORD")
			      (gethash :variables meta))
		     (gensym)))))
	(t element)))

(defun format-array (values)
  "Format an APL array, passing through values that are already arrays."
  (if (or (stringp (first values))
	  (symbolp (first values))
	  (and (not (second values))
	       (or (listp (first values))
		   (functionp (first values)))))
      ;; if the first item is a list (i.e. code to generate an array of some kind),
      ;; pass it through with no changes. Also pass through strings, which are already arrays,
      ;; any symbols
      (first values)
      `(make-array (list ,(length values))
		   :initial-contents (list ,@values))))

(defun format-function (idiom-name content)
  "Format an APL function, reversing the order of alpha and omega arguments to reflect the argument order of Lisp as opposed to APL."
  (let ((⍺ (intern "⍺" idiom-name))
	(⍵ (intern "⍵" idiom-name)))
    (lambda (meta axes omega &optional alpha)
      (declare (ignorable meta axes))
      `(funcall (lambda (,⍵ &optional ,⍺)
		  (declare (ignorable ,⍺ ,⍵))
		  ,content)
		;; note: enclosing the arguments slows performance when iterating over many values,
		;; but there is no other simple way to ensure the arguments received are arrays
		(enclose ,(macroexpand omega))
		,@(if alpha (list (list 'enclose (macroexpand alpha))))))))

(defun enclose (item)
  "Enclose non-array values, passing through arguments that are already arrays."
  (if (arrayp item)
      item (vector item)))

(defun process-output-vector (items)
  "Process items in a vector to be generated by the compiler, wrapping any array references in aplSymbol so that they are disclosed. This does not apply if the output vector is unitary (length 1)."
  (loop for item in items collect (if (and (< 1 (length items))
					   (listp item)
					   (eql 'aref-eliding (first item)))
				      (list 'disclose item)
				      item)))

(defun assemble-value (idiom meta subprocessor precedent exp &optional output axes prior-expression)
  "Assemble a value from tokens output by the parser; this may be a space-separated vector or a unitary value (processed as a 1-element vector by APL)."
  (labels ((axis-enclose (body axis-specs)
	     (if (not axis-specs)
		 body
		 (axis-enclose `(aref-eliding ,body
					      (mapcar (lambda (vector)
							(if vector (if (= 1 (length vector))
								       (- (aref vector 0)
									  (of-state (local-idiom april)
										    :count-from))
								       (mapcar (lambda (elem)
										 (- elem (of-state
											  (local-idiom april)
											  :count-from)))
									       (array-to-list vector)))))
						      (list ,@(mapcar (lambda (spec)
									(funcall subprocessor
										 idiom meta
										 (list (list spec))))
								      (first axis-specs)))))
			       (rest axis-specs)))))
    (if (or (not exp)
	    (and (symbolp (first exp))
		 (or (not (listp (first prior-expression)))
		     (not (eql #\← (third (first prior-expression)))))
		 (gethash (first exp)
			  (gethash :functions meta)))
	    ;; break if the current expression is a pivotal operator expression composing a function
	    ;; and there is a preceding expression, which in this case must be a monadic function with
	    ;; something on its right side
	    (and prior-expression
	    	 (listp (first exp))
	    	 (listp (caar exp))
		 (not (loop for subex in (caar exp) never (and (listp subex)
							       (eq :op (first subex))
							       (eq :pivotal (second subex))))))
	    ;; break if the next symbol represents a function and should be processed by assembleOperation
	    (and (listp (first exp))
		 (keywordp (caar exp))
		 (or (not (eq :axes (caar exp)))
		     (let ((element (second exp)))
		       (and (listp element)
			    (keywordp (first element))
			    (not (eq :axes (first element))))))
		 ;; break on axes if the next element is an operation rather than a value
		 (or (not (eq :fn (caar exp)))
		     ;; if the first element in the expression is a function,
		     ;; it's a function composition expression
		     (not (functionp (cadar exp)))
		     output precedent)))
	(values (cond ((not output)
		       (if (and (not precedent)
				(eq :fn (caar exp)))
			   :fun-comp))
		      ((and (= 1 (length output))
			    ;; disclose strings since they're treated as arrays
			    ;; disclose arrays and lists (which specify computed values)
			    ;; disclose single symbols since any value they represent will be vectorized
			    (or (stringp (first output))
				(symbolp (first output))
				(listp (first output))
				(arrayp (first output))))
		       (first output))
		      ((and (listp (first output))
			    (eql 'lambda (caar output)))
		       ;; break if the last element was a composed operation, remove the first element of output,
		       ;; which is instead prepended to the remaining elements in the expression
		       (cons 'normalizing-vector (process-output-vector (rest output))))
		      (t (cons 'normalizing-vector (process-output-vector output))))
		(if (and (listp (first output))
			 (eql 'lambda (caar output))
			 (rest output))
		    ;; if the last element was a composed operation, prepend it to the remaining expression
		    (cons (list :composed-operation (car output))
			  exp)
		    exp))
	(assemble-value idiom meta subprocessor precedent (rest exp)
			(cons (cond ((and (listp (first exp))
					  (eq :axes (caar exp)))
				     ;; this placeholder keyword is removed in the next iteration
				     :axes-placeholder)
				    ((and (listp (first exp))
					  (not (keywordp (caar exp))))
				     ;; if the element is a list and doesn't begin with a keyword,
				     ;; it's a closure and should be handled by the expression processor
				     (axis-enclose (first (mapcar (lambda (sub-exp)
								    (funcall subprocessor
									     idiom meta sub-exp))
								  (first exp)))
						   axes))
				    ((and (listp (first exp))
					  (eq :fn (caar exp)))
				     `(lambda (omega &optional alpha)
					,(funcall (cadar exp)
						  meta nil 'omega 'alpha)))
				    ((symbolp (first exp))
				     (axis-enclose
				      ;; symbol preprocessing is not applied to ⍺ and ⍵
				      ;; since they represent arguments to a function that already went
				      ;; through processing
				      (if (or (eql '⍺ (first exp))
					      (eql '⍵ (first exp))
					      (and (not output)
						   (not precedent)))
					  ;; don't disclose unitary vectors if the expression content is ⍺ or ⍵
					  ;; and thus referring to preprocessed variables or if the symbol is
					  ;; the only element in the expression,with no output or
					  ;; precedent present.
					  `(disclose-within-vector ,(first exp))
					  `(disclose ,(first exp)))
				      axes))
				    (t (axis-enclose (first exp)
						     axes)))
			      ;; :axes-placeholder is removed here if axes are being processed this iteration
			      (if axes (rest output)
				  output))
			(if (and (listp (first exp))
				 (eq :axes (caar exp)))
			    (cons (cdar exp)
				  axes))))))

(defun assemble-operation (idiom meta subprocessor precedent exp &key (axes nil) (from-pivot nil))
  "Assemble an APL operation from parsed tokens. The simplest operations consist of a single function, like '+', while operators can be combined with functions to form more complex operations."
  (let ((head (first exp))
	(next (second exp))
	(tail (rest exp)))
    (macrolet ((get-function (symbol)
		 `(let ((function (if (or (characterp ,symbol)
					  (symbolp ,symbol))
				      (of-functions idiom ,symbol)
				      ,symbol)))
		    (if axes (lambda (meta unused omega &optional alpha)
			       (declare (ignore unused))
			       (funcall function meta
					(mapcar (lambda (sub-expr)
						  (funcall subprocessor idiom meta sub-expr))
						axes)
					omega alpha))
			function))))
      (cond ((symbolp head)
	     ;; if the head is a function-denoting symbol, wrap the symbol in the appropriate function call
	     ;; syntax and return it with the tail
	     (values (lambda (meta axes omega &optional alpha)
		       (declare (ignore meta axes))
		       `(funcall ,head ,omega ,@(if alpha (list alpha))))
		     tail))

	    ((and (eq :composed-operation (first head)))
	     ;; if the head is a composed operation, wrap appropriately and return with the tail
	     (values (lambda (meta axes omega &optional alpha)
		       (declare (ignore meta axes))
		       `(funcall ,(second head) ,omega ,@(if alpha (list alpha))))
		     tail))
	    
	    ((eq :axes (first head))
	     ;; if an axes object is found, process the next item in the list with the :axes option
	     ;; filled with the found object
	     (multiple-value-bind (following-axes from-following-axes)
		 (assemble-operation idiom meta subprocessor precedent tail
				     :axes (rest head))
	       (values following-axes from-following-axes)))
	    
	    ((and (eq :fn (first head))
		  (or (not tail)
		      (not (listp next))
		      (not (and (listp next)
				(keywordp (first next))))
		      (eq :fn (first next))
		      (eq :axes (first next))
		      (and (eq :op (first next))
			   (eq :lateral (second next)))))
	     ;; finish assembling the operation if the token list is at its end, the next item is not a
	     ;; function or operator, or the next item is another function or right operand
	     (values (get-function (second head))
		     tail))

	    ((and (eq :fn (first head))
		  (eq :op (first next))
		  (eq :pivotal (second next)))
	     ;; if the next glyph is a pivotal operator glyph, perform the first stage of its assembly
	     ;; and then execute the resulting operation on the head glyph, thus completing the assembly
	     (multiple-value-bind (following-op from-following-op)
		 (assemble-operation idiom meta subprocessor precedent tail)
	       (values (funcall following-op meta (cons 'list axes)
				(get-function (second head)))
		       from-following-op)))

	    ((and (eq :op (first head))
	    	  (or from-pivot (not (eq :pivotal (second head))))
	    	  ;; note: pivotal operator glyphs cannot be overloaded as function glyphs if they follow
	    	  ;; another pivotal operator glyph
	    	  (or (not tail)
	    	      (not (or (and (listp next)
				    (eq :fn (first next)))
			       (and (symbolp next)
				    (not (eql #\← (third head)))
				    (gethash next (gethash :functions meta)))))))
	     ;; if no function follows a lateral operator glyph, check whether it's actually an overloaded
	     ;; function glyph and reassign if so
	     (if (of-overloaded? idiom (first (last head)))
	    	 (values (get-function (first (last head)))
	    		 tail)
	    	 (error "Found operator with no accompanying function.")))

	    ((eq :op (first head))
	     ;; handle any other operator
	     (multiple-value-bind (following-op from-following-op)
		 (if (or (and (listp next)
			      (keywordp (first next)))
			 (and (symbolp next)
			      (not (char= #\← (third head)))
			      (gethash next (gethash :functions meta))))
		     (assemble-operation idiom meta subprocessor precedent tail :from-pivot t)
		     (assemble-value idiom meta subprocessor precedent tail))
	       (values (funcall (of-operators idiom (first (last head)))
				meta (cons 'list (mapcar (lambda (item) (cons 'vector item))
							 axes))
				following-op)
		       from-following-op)))
	    ((and exp precedent (listp (first exp))
		  (listp (caar exp)))
	     ;; if this is the beginning of a composed operation following a function character,
	     ;; build the operation using the subprocessor and pass back the function to combine it
	     ;; with the precedent
	     ;; (print (list :erer exp precedent))
	     ;; (print (funcall subprocessor idiom meta exp))
	     (values (lambda (meta axes omega &optional alpha)
		       (declare (ignore axes))
		       `(funcall ,(funcall subprocessor idiom meta exp)
				 ,omega ,@(if alpha (list alpha))))
		     tail))))))

(defun left-invert-matrix (in-matrix)
  (let* ((input (if (= 2 (rank in-matrix))
		    in-matrix (make-array (list (length in-matrix) 1)
					  :element-type (element-type in-matrix)
					  :initial-contents (loop for i from 0 to (1- (length in-matrix))
							       collect (list (aref in-matrix i))))))
	 (result (array-inner-product
		  (invert-matrix (array-inner-product (aops:permute (reverse (iota (rank input)))
								    input)
						      input
						      (lambda (arg1 arg2) (apply-scalar-dyadic #'* arg1 arg2))
						      #'+))
		  (aops:permute (reverse (iota (rank input)))
				input)
		  (lambda (arg1 arg2) (apply-scalar-dyadic #'* arg1 arg2))
		  #'+)))
    (if (= 1 (rank in-matrix))
	(aref (aops:split result 1) 0)
	result)))

(defun compose-stage (left-operand)
  "Perform a stage of function composition for the compose operation (∘)."
  (let* ((left-evaluated (if (functionp left-operand)
			     (funcall left-operand nil :marker 'omega 'alpha)
			     left-operand))
	 (functions nil))
    (lambda (meta unused right-operand &optional alpha)
      (declare (ignore unused alpha))
      (cond ((not (functionp right-operand))
	     ;; if the right operand isn't a function, curry accordingly
	     `(lambda (omega)
		(funcall (lambda (omega alpha) ,(funcall left-operand meta nil 'omega 'alpha))
			 ,right-operand omega)))
	    ((not (functionp left-operand))
	     ;; if the left operand isn't a function, curry by building the appropriate function and passing it
	     ;; to the next operation assembly stage if there is no :fun-comp omega value denoting that this is
	     ;; the only stage of assembly
	     (lambda (meta axes omega &optional alpha)
	       (declare (ignore axes alpha))
	       (if (eq :fun-comp omega)
		   `(lambda (omega)
		      (funcall (lambda (omega alpha) ,(funcall right-operand meta nil 'omega 'alpha))
			       omega ,left-operand))
		   (list (lambda (meta axes omega &optional alpha)
			   (declare (ignore axes omega alpha))
			   `(funcall (lambda (omega &optional alpha)
				       ,(funcall right-operand meta nil 'omega 'alpha))
				     omega ,left-operand))))))
	    (t (lambda (meta &optional axes omega alpha)
		 (if (not (eq :fun-comp omega))
		     (setq functions (if (functionp (first left-evaluated))
					 (cons right-operand left-evaluated)
					 (list right-operand left-operand))))
		 ;; note: the alpha-comp and omega-comp variables are enclosed below in case they are passed in as
		 ;; scalars; this causes slowdown when iterating over many values
		 (labels ((wrap (with-alpha fnlist body)
			    (if fnlist
				(wrap with-alpha (rest fnlist)
				      `(funcall (lambda (omega ,@(if (and with-alpha (not (rest fnlist)))
								     (list 'alpha)))
						  ,@(if (and with-alpha (not (rest fnlist)))
							`((declare (ignorable alpha))))
						  ;; alpha is ignorable in the case of a left-curried value
						  ,(if (functionp (first fnlist))
						       (funcall (first fnlist)
								meta nil 'omega
								(if (and with-alpha (not (rest fnlist)))
								    'alpha))
						       (first fnlist)))
						,@(if (and with-alpha (not (rest fnlist)))
						      `((enclose alpha-comp)))
						,body))
				body)))
		   (if (not (eq :marker axes))
		       (funcall (if (eq :fun-comp omega)
				    #'values (lambda (body) `(funcall ,body ,omega ,alpha)))
				`(lambda (omega-comp &optional alpha-comp)
				   (if alpha-comp
				       ,(wrap t (if (functionp (first left-evaluated))
						    left-evaluated (list left-operand))
					      `(funcall (lambda (omega) ,(funcall right-operand meta nil 'omega))
							(enclose omega-comp)))
				       ,(wrap nil (if (functionp (first left-evaluated))
						      left-evaluated
						      (list left-operand))
					      `(funcall (lambda (omega) ,(funcall right-operand meta nil 'omega))
							(enclose omega-comp))))))
		       functions))))))))

(defun over-operator-template (axes function &key (first-axis nil) (for-vector nil) (for-array nil))
  "Build a function to generate code apply functions over arrays, as for APL's reduce and scan operators."
  (lambda (meta unused omega &optional alpha)
    (declare (ignore unused alpha))
    (let ((wrapped-function `(lambda (omega alpha) ,(funcall function meta nil 'omega 'alpha))))
      `(let ((new-array (copy-array ,omega)))
	 (disclose (if (vectorp new-array)
		       (funcall ,for-vector ,wrapped-function new-array)
		       (funcall ,for-array ,wrapped-function new-array
				(if ,axes (1- (aref (first ,axes) 0))
				    ,(if first-axis 0 `(1- (rank new-array)))))))))))

(vex-spec
 april
 (state :count-from 1
	:disclose-output t
	:atomic-vector
	(concatenate 'string "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`"
		     "abcdefghijklmnopqrstuvwxyz{|}~¥€⇄∧∼≬⋆⋸⌸⌺⌼⌾⍁¡⍣⍅⎕⍞⌹⍆⍤⍇⍈⍊⊤λ⍍⍏£⊥⍶⌶⍐⍑χ≢⍖⍗"
		     "⍘⍚⍛⌈⍜⍢∪⍨⍕⍎⍬⍪∣│┤⍟∆∇→╣║╗╝←⌊┐└┴┬├─┼↑↓╔╚╩╦╠═╬≡⍸⍷∵⌷⍂⌻⊢⊣⋄┘┌█▄▌▐▀"
		     "⍺⍹⊂⊃⍝⍲⍴⍱⌽⊖○∨⍳⍉∈∩⌿⍀≥≤≠×÷⍙∘⍵⍫⍋⍒¯¨"))

 (utilities :match-blank-character
	    (lambda (char) (member char (list #\  #\Tab)))
	    :match-newline-character
	    (lambda (char) (member char (list #\◊ #\⋄ #\Newline #\Return)))
	    :match-token-character
	    (lambda (char)
	      ;; the ¯ character must be expressed as #\macron to be correctly processed
	      ;; the ̄ (combining_macron) character can be denoted normally, however
	      (or (alphanumericp char)
		  (member char (list #\∆ #\⍙ #\¯ #\. #\⍺ #\⍵ #\⍬))))
	    :prep-code-string
	    (lambda (string)
	      ;; this code preprocessor removes comments, including comment-only lines
	      (regex-replace-all (concatenate 'string "^\\s{0,}⍝(.*)[\\r\\n]|(?<=[\\r\\n])\\s{0,}⍝(.*)[\\r\\n]"
					      "|(?<=[\\r\\n])\\s{0,}⍝(.*)[\\r\\n]"
					      "|(?<=[^\\r\\n])\\s{0,}⍝(.*)(?=[\\r\\n])")
				 string ""))
	    :process-axis-string
	    (lambda (string) (cl-ppcre:split #\; string))
	    :format-value #'format-value
	    :format-object #'format-array
	    :format-function #'format-function
	    :mediate-operation-macro 'mediate-operation
	    :assemble-value #'assemble-value
	    :assemble-operation #'assemble-operation
	    :apply-scalar-monadic #'apply-scalar-monadic
	    :apply-scalar-dyadic #'apply-scalar-dyadic
	    :postprocess-compiled
	    (lambda (form)
	      ;; wrap the last element of the compiled output in a disclose form if discloseOutput is set
	      (if (of-state (local-idiom april)
			    :disclose-output)
		  (append (butlast form)
			  (list (list 'disclose (first (last form)))))
		  form))
	    :postprocess-value
	    (lambda (item)
	      (if (of-state (local-idiom april)
			    :disclose-output)
		  (list 'disclose item)
		  item)))

 (functions (← (has :title "Assign")
	       (dyadic (macro (lambda (meta axes omega alpha)
	    			(declare (ignorable axes))
	    			(if (and (listp alpha)
	    				 (eql 'aref-eliding (first alpha)))
	    			    (append alpha (list :set omega))
	    			    (let ((symbol (if (listp alpha)
	    					      (second alpha)
	    					      alpha)))
	    			      (if (and (listp omega)
					       (or (eql 'lambda (first omega))
						   (and (listp (second omega))
							(eql 'lambda (caadr omega)))))
	    				  ;; assign from either a disclosed or enclosed function definition,
	    				  ;; i.e. a←⍴∘⍴ or a←(⍴∘⍴).
	    				  (setf (gethash symbol (gethash :functions meta))
						omega)
					  (setf (gethash symbol (gethash :values meta))
						omega))
	    			      `(setq ,symbol ,omega))))))
	       (tests (is "x←55 ⋄ x" 55)
	    	      (is "x←2 3 4⍴⍳9 ⋄ x[;1;]←7 ⋄ x" #3A(((7 7 7 7) (5 6 7 8) (9 1 2 3))
	    						  ((7 7 7 7) (8 9 1 2) (3 4 5 6))))))
	    (⊣ (has :titles ("Empty" "Left"))
	       (ambivalent (args :any (lambda (omega)
	    				(declare (ignore omega))
	    				(make-array (list 0))))
	    		   (args :any :any (lambda (omega alpha)
	    				     (declare (ignore omega))
	    				     alpha)))
	       (tests (is "⊣77" #())
		      (is "55⊣77" 55)))
	    (⊢ (has :titles ("Identity" "Right"))
	       (ambivalent (args :any (lambda (omega) omega))
	    		   (args :any :any (lambda (omega alpha)
	    				     (declare (ignore alpha))
	    				     omega)))
	       (tests (is "⊢77" 77)
		      (is "55⊢77" 77)))
	    (+ (has :titles ("Identity or Negate Imaginary" "Add"))
	       (ambivalent :asymmetric-scalar (lambda (omega) (if (complexp omega)
								  (complex (realpart omega)
									   (- (imagpart omega)))
								  omega))
			   +)
	       (tests (is "+5" 5)
		      (is "+5J2" #C(5 -2))
		      (is "1+1" 2)
		      (is "1+1 2 3" #(2 3 4))))
    	    (- (has :titles ("Negate" "Subtract"))
	       (ambivalent :symmetric-scalar (reverse-op -))
	       (tests (is "2-1" 1)
		      (is "7-2 3 4" #(5 4 3))))
     	    (× (has :titles ("Sign" "Multiply"))
	       (ambivalent :asymmetric-scalar signum *)
	       (tests (is "×20 5 0 ¯5 5 ¯9" #(1 1 0 -1 1 -1))
		      (is "2×3" 6)
		      (is "4 5×8 9" #(32 45))))
     	    (÷ (has :titles ("Reciprocal" "Divide"))
	       (ambivalent :symmetric-scalar (reverse-op /))
	       (tests (is "6÷2" 3)
		      (is "12÷6 3 2" #(2 4 6))
		      (is "÷2 4 8" #(1/2 1/4 1/8))))
     	    (⋆ (has :titles ("Exponential" "Power"))
	       (ambivalent :asymmetric-scalar exp (reverse-op expt))
	       (tests (is "⌊1000×⋆2" 7389)
		      (is "2⋆4" 16)
		      (is "⌊16⋆÷2" 4)))
     	    (* (has :titles ("Exponential" "Power"))
	       (ambivalent :asymmetric-scalar exp (reverse-op expt)))
     	    (⍟ (has :titles ("Natural Logarithm" "Logarithm"))
	       (ambivalent :symmetric-scalar log)
	       (tests (is "⌊1000×⍟5" 1609)
		      (is "⌊2⍟8" 3)))
     	    (\| (has :titles ("Magnitude" "Residue"))
	    	(ambivalent :asymmetric-scalar abs mod)
		(tests (is "|55" 55)
		       (is "|¯33" 33)
		       (is "8|39" 7)))
     	    (! (has :titles ("Factorial" "Binomial"))
	       (ambivalent :asymmetric-scalar sprfact binomial)
	       (tests (is "!5" 120)
		      (is "5!12" 792)))
     	    (⌈ (has :titles ("Ceiling" "Maximum"))
	       (ambivalent :asymmetric-scalar ceiling (reverse-op max))
	       (tests (is "⌈1.0001" 2)
		      (is "⌈1.9998" 2)
		      (is "3⌈0 1 2 3 4 5" #(3 3 3 3 4 5))))
     	    (⌊ (has :titles ("Floor" "Minimum"))
	       (ambivalent :asymmetric-scalar floor (reverse-op min))
	       (tests (is "⌊1.0001" 1)
		      (is "⌊1.9998" 1)
		      (is "3⌊0 1 2 3 4 5" #(0 1 2 3 3 3))))
 	    (? (has :titles ("Random" "Deal"))
 	       (ambivalent (args :scalar (lambda (omega)
 	    				   (+ (random omega)
 	    				      (of-state (local-idiom april)
							:count-from))))
 	    		   (args :one :one (lambda (omega alpha)
 	    				     (make-array (list alpha)
 	    						 :initial-contents
 	    						 (loop for i from 0 to (1- alpha)
 	    						    collect (+ (random omega)
 	    							       (of-state (local-idiom april)
										 :count-from))))))))
     	    (○ (has :titles ("Pi Times" "Circular"))
 	       (ambivalent (args :scalar (lambda (omega) (* pi omega)))
 	    		   (args :any :one (lambda (omega alpha)
					     (let ((fn (vector (lambda (input) (exp (* input #C(0 1))))
							       (lambda (input) (* input #C(0 1)))
							       (lambda (input) (if (complexp input)
										   (complex (realpart input)
											    (- (imagpart input)))
										   input))
							       #'values
							       (lambda (input) (sqrt (- -1 (* 2 input))))
							       #'atanh #'acosh #'asinh
							       (lambda (input) (* (sqrt (/ (1+ input) (1- input)))
										  (1+ input)))
							       #'atan #'acos #'asin
							       (lambda (input) (sqrt (- 1 (* 2 input))))
							       #'sin #'cos #'tan
							       (lambda (input) (sqrt (1+ (* 2 input))))
							       #'sinh #'cosh #'tanh
							       (lambda (input) (sqrt (- -1 (* 2 input))))
							       #'realpart #'abs #'imagpart #'phase)))
 	    				       ;; the twelfth element of the vector corresponds to
 	    				       ;; index 0, hence an offset of 12 from the vector's first element
 	    				       (apply-scalar-monadic (aref fn (+ 12 alpha))
 								     omega)))))
 	       (tests (is "⌊100000×○1" 314159)
 		      (is "(⌊1000×1÷2⋆÷2)=⌊1000×1○○÷4" 1)))
 	    (\~ (has :titles ("Not" "Without"))
 	    	(ambivalent (args :scalar
 				  (boolean-op (lambda (omega)
 						(cond ((= 0 omega) t)
 						      ((= 1 omega) nil)
 						      (t (error
 							  "Domain error: arguments to ~ must be 1 or 0."))))))
 	    		    (args :any :any (lambda (omega alpha)
 	    				      (let ((to-exclude (if (stringp omega)
 	    							    (array-to-list omega)
 	    							    (array-to-list (make-array
 	    									    (list (array-total-size omega))
 	    									    :displaced-to omega))))
 	    					    (included nil))
 	    					(aops:each (lambda (element)
 	    						     (if (not (member element to-exclude))
 	    							 (setq included (cons element included))))
 	    						   alpha)
 	    					(make-array (list (length included))
 	    						    :element-type (element-type alpha)
 	    						    :initial-contents (reverse included))))))
 	    	(tests (is "~1 0 1" #(0 1 0))
 	    	       (is "1 2 3 4 5 6 7~3 5" #(1 2 4 6 7))
 	    	       (is "'MACARONI'~'ALFREDO'" "MCNI")))
     	    (< (has :title "Less")
 	       (dyadic (args :scalar (reverse-boolean-op <)))
 	       (tests (is "3<1 2 3 4 5" #(0 0 0 1 1))))
     	    (≤ (has :title "Less or Equal")
 	       (dyadic (args :scalar (reverse-boolean-op <=)))
 	       (tests (is "3≤1 2 3 4 5" #(0 0 1 1 1))))
     	    (= (has :title "Equal")
 	       (dyadic (args :scalar (boolean-op (lambda (omega alpha)
						   (funcall (cond ((and (numberp alpha)
									(numberp omega))
								   #'=)
								  ((and (characterp alpha)
									(characterp omega))
								   #'char=))
							    omega alpha)))))
 	       (tests (is "3=1 2 3 4 5" #(0 0 1 0 0))))
     	    (≥ (has :title "Greater or Equal")
 	       (dyadic (args :scalar (reverse-boolean-op >=)))
 	       (tests (is "3≥1 2 3 4 5" #(1 1 1 0 0))))
     	    (> (has :title "Greater")
 	       (dyadic (args :scalar (reverse-boolean-op >)))
 	       (tests (is "3>1 2 3 4 5" #(1 1 0 0 0))))
     	    (≠ (has :title "Not Equal")
 	       (dyadic (args :scalar (reverse-boolean-op /=)))
 	       (tests (is "3≠1 2 3 4 5" #(1 1 0 1 1))))
 	    (≡ (has :titles ("Depth" "Match"))
 	       (ambivalent (args :any array-depth)
 	    		   (args :any :any (reverse-boolean-op array-compare)))
	       (tests (is "≡1 (2 3) (4 5 (6 7)) (8)" 3)))
 	    (≢ (has :titles ("First Dimension" "Not Match"))
 	       (ambivalent (args :any (lambda (omega) (first (dims omega))))
 			   (args :any :any (boolean-op (lambda (omega alpha)
 							 (not (array-compare omega alpha))))))
	       (tests (is "≢1 2 3" 3)
		      (is "≢2 3 4⍴⍳9" 2)))
 	    (^ (has :title "And")
 	       (dyadic (args :scalar (reverse-op lcm))))
 	    (∧ (has :title "And")
 	       (dyadic (args :scalar (reverse-op lcm)))
 	       (tests (is "0 1 0 1 ∧ 0 0 1 1" #(0 0 0 1))))
 	    (⍲ (has :title "Nand")
 	       (dyadic (args :scalar (boolean-op (lambda (omega alpha) (not (= omega alpha 1))))))
 	       (tests (is "0 1 0 1 ⍲ 0 0 1 1" #(1 1 1 0))))
     	    (∨ (has :title "Or")
 	       (dyadic (args :scalar (reverse-op gcd)))
 	       (tests (is "0 1 0 1 ∨ 0 0 1 1" #(0 1 1 1))))
 	    (⍱ (has :title "Nor")
 	       (dyadic (args :scalar (boolean-op (lambda (omega alpha) (= omega alpha 0)))))
 	       (tests (is "0 1 0 1 ⍱ 0 0 1 1" #(1 0 0 0))))
 	    (⍳ (has :titles ("Index" "Index Of"))
 	       (ambivalent (args :one (lambda (omega)
 	    				(make-array (list omega)
 	    					    :initial-contents
 	    					    (alexandria:iota omega
								     :start (of-state (local-idiom april)
										      :count-from)))))
			   (args :any :any (lambda (omega alpha)
					     (index-of omega alpha (of-state (local-idiom april)
									     :count-from)))))
 	       (tests (is "⍳5" #(1 2 3 4 5))
 	    	      (is "3⍳1 2 3 4 5" #(2 2 1 2 2))))
     	    (⍴ (has :titles ("Shape" "Reshape"))
 	       (ambivalent (args :any (lambda (omega)
 					(let ((omega-dims (dims omega)))
 					  (make-array (list (length omega-dims))
 						      :initial-contents omega-dims))))
 	    		   (args :any :any (lambda (omega alpha)
 	    				     (reshape-array-fitting omega (array-to-list alpha)))))
 	       (tests (is "⍴1 2 3" 3)
 		      (is "⍴3 5⍴⍳8" #(3 5))
 		      (is "4 5⍴⍳3" #2A((1 2 3 1 2) (3 1 2 3 1) (2 3 1 2 3) (1 2 3 1 2)))))
 	    (⌷ (has :title "At Axes")
 	       (dyadic (args :any :any :axes
 			     (lambda (omega alpha &optional axes)
 			       (if axes
 				   (let ((elided-coords (loop for i from 0 to (1- (rank omega))
 							   collect nil)))
 				     (loop for index from 0 to (1- (length (first axes)))
 					do (setf (nth (- (aref (first axes) index)
 							 (of-state (local-idiom april)
								   :count-from))
 						      elided-coords)
 						 (- (aref alpha index)
 						    (of-state (local-idiom april)
							      :count-from))))
 				     (aref-eliding omega elided-coords))
 				   (let* ((coords (mapcar (lambda (coord) (- coord (of-state (local-idiom april)
											     `:count-from)))
 							  (array-to-list alpha)))
 					  (found (apply #'aref (cons omega coords))))
 				     (if (not (arrayp found))
 					 (vector found)
 					 found))))))
 	       (tests (is "3⌷⍳9" 3)
 		      (is "2 2⌷4 5⍴⍳9" 7)
 		      (is "2 3 4⌷4 5 6⍴⍳9" 1)
 		      (is "1 3⌷[1 2]2 3 4⍴⍳5" #(4 5 1 2))))
 	    (∊ (has :titles ("Enlist" "Membership"))
 	       (ambivalent (args :any enlist)
 	    		   (args :any :any (lambda (omega alpha)
 	    				     (let ((output (make-array (dims alpha))))
 	    				       (dotimes (index (array-total-size output))
 	    					 (let ((found nil))
 	    					   (aops:each (lambda (input)
 	    							(cond ((and (numberp input)
 	    								    (numberp (row-major-aref alpha index))
 	    								    (= input (row-major-aref alpha index)))
 	    							       (setq found t))
 	    							      ((and (characterp input)
 	    								    (characterp (row-major-aref alpha
 													index))
 	    								    (char= input
 	    									   (row-major-aref alpha index)))
 	    							       (setq found t))))
 	    						      omega)
 	    					   (setf (row-major-aref output index)
 	    						 (if found 1 0))))
 	    				       output))))
 	       (tests (is "∊2 2 2⍴⍳9" #(1 2 3 4 5 6 7 8))
 	    	      (is "2 5 7∊1 2 3 4 5" #(1 1 0))))
 	    (⍷ (has :title "Find")
 	       (dyadic (args :any :any find-array))
 	       (tests (is "(2 2⍴6 7 1 2)⍷2 3 4⍴⍳9" #3A(((0 0 0 0) (0 1 0 0) (0 0 0 0))
 						       ((0 0 1 0) (0 0 0 0) (0 0 0 0))))))
 	    (↑ (has :titles ("Disclose" "Take"))
 	       (ambivalent (args :any (lambda (omega)
 	    				(if (or (not (vectorp omega))
 	    					(not (arrayp (aref omega 0))))
 	    				    omega (aref omega 0))))
 	    		   (args :any :any :axes
 	    			 (lambda (omega alpha &optional axes)
 	    			   (multidim-slice omega (if axes
 							     (loop for axis from 0 to (1- (rank omega))
 								collect (if (= axis (- (aref (first axes) 0)
 										       (of-state
											(local-idiom april)
											:count-from)))
 									    (aref alpha 0)
 									    (nth axis (dims omega))))
 							     (array-to-list alpha))
 	    					   :fill-with 0))))
 	       (tests (is "↑⊂1 2 3 4" #(1 2 3 4))
 	    	      (is "2 3 4↑4 5 6⍴⍳9" #3A(((1 2 3 4) (7 8 9 1) (4 5 6 7))
 	    				       ((4 5 6 7) (1 2 3 4) (7 8 9 1))))
 		      (is "1↑[1]2 3 4⍴⍳9" #3A(((1 2 3 4) (5 6 7 8) (9 1 2 3))))
 		      (is "1↑[2]2 3 4⍴⍳9" #3A(((1 2 3 4)) ((4 5 6 7))))
 		      (is "2↑[2]2 3 4⍴⍳9" #3A(((1 2 3 4) (5 6 7 8)) ((4 5 6 7) (8 9 1 2))))
 		      (is "2↑[3]2 3 4⍴⍳9" #3A(((1 2) (5 6) (9 1)) ((4 5) (8 9) (3 4))))))
 	    (↓ (has :titles ("Split" "Drop"))
 	       (ambivalent (args :any :axes (lambda (omega &optional axes)
 	    				      (aops:split omega (if axes (aref (first axes) 0)
 	    							    (1- (rank omega))))))
 	    		   (args :any :any :axes
 	    			 (lambda (omega alpha &optional axes)
 	    			   (multidim-slice omega
 						   (if axes (loop for axis from 0 to (1- (rank omega))
 							       collect (if (= axis (- (aref (first axes) 0)
 										      (of-state (local-idiom april)
 												:count-from)))
 									   (aref alpha 0)
 									   0))
 						       (array-to-list alpha))
 	    					   :inverse t))))
 	       (tests (is "↓3 4⍴⍳9" #(#(1 2 3 4) #(5 6 7 8) #(9 1 2 3)))
 	    	      (is "2 2 2↓4 5 6⍴⍳9" #3A(((3 4 5 6) (9 1 2 3) (6 7 8 9))
 	    				       ((6 7 8 9) (3 4 5 6) (9 1 2 3))))
 		      (is "1↓[1]2 3 4⍴⍳9" #3A(((4 5 6 7) (8 9 1 2) (3 4 5 6))))
 		      (is "1↓[2]2 3 4⍴⍳9" #3A(((5 6 7 8) (9 1 2 3)) ((8 9 1 2) (3 4 5 6))))
 		      (is "2↓[2]2 3 4⍴⍳9" #3A(((9 1 2 3)) ((3 4 5 6))))
 		      (is "2↓[3]2 3 4⍴⍳9" #3A(((3 4) (7 8) (2 3)) ((6 7) (1 2) (5 6))))
		      (is "¯2↓⍳9" #(1 2 3 4 5 6 7))
		      (is "¯2 ¯2↓5 8⍴⍳9" #2A((1 2 3 4 5 6) (9 1 2 3 4 5) (8 9 1 2 3 4)))))
 	    (\, (has :titles ("Ravel" "Catenate or Laminate"))
 	    	(ambivalent (args :any :axes
 				  (lambda (omega &optional axes)
 				    (ravel (of-state (local-idiom april)
						     :count-from)
 					   omega axes)))
 	    		    (args :any :any :axes
 	    			  (lambda (omega alpha &optional axes)
 	    			    (if (and (or (not axes)
 						 (integerp (aref (first axes) 0)))
 					     (vectorp alpha)
 	    				     (vectorp omega))
 	    				(if (and axes (< 0 (- (aref (first axes) 0)
 							      (of-state (local-idiom april)
									:count-from))))
 					    (error (concatenate
 						    'string "Specified axis is greater than 1, vectors"
 						    " have only one axis along which to catenate."))
 					    (if (and axes (> 0 (- (aref (first axes) 0)
 								  (of-state (local-idiom april)
									    :count-from))))
 						(error (format nil "Specified axis is less than ~a."
 							       (of-state (local-idiom april)
									 :count-from)))
 						(concatenate 'vector alpha omega)))
 	    				(if (or (not axes)
 						(integerp (aref (first axes) 0)))
 					    (let* ((axis (if axes (- (aref (first axes) 0)
								     (of-state (local-idiom april)
									       :count-from))
							     (1- (max (array-rank alpha)
								      (array-rank omega)))))
						   (scale-alpha (if (not (is-singleton alpha))
								    alpha (scale-array alpha omega axis)))
						   (scale-omega (if (not (is-singleton omega))
								    omega (scale-array omega alpha axis))))
					      (aops:stack axis scale-alpha scale-omega))
 					    ;; laminate in the case of a fractional axis argument
 					    (let* ((axis (ceiling (- (aref (first axes) 0)
 								     (of-state (local-idiom april)
									       :count-from))))
 						   (permute-dims (alexandria:iota (1+ (rank alpha))))
 						   (p-alpha (if (not (is-singleton alpha))
 								(aops:permute (rotate-right axis permute-dims)
 									      (array-promote alpha))))
 						   (p-omega (if (not (is-singleton omega))
 								(aops:permute (rotate-right axis permute-dims)
 									      (array-promote omega)))))
 					      ;; a 1-element array argument to laminate is scaled to
 					      ;; match the other array's dimensions
 					      (aops:stack axis (if (is-singleton alpha)
								   (scale-array alpha p-omega)
								   p-alpha)
 							  (if (is-singleton omega)
 							      (scale-array omega p-alpha)
 							      p-omega))))))))
 	    	(tests (is ",3 4⍴⍳9" #(1 2 3 4 5 6 7 8 9 1 2 3))
 		       (is ",[0.5]3 4⍴⍳9" #3A(((1 2 3 4) (5 6 7 8) (9 1 2 3))))
 		       (is ",[1.5]3 4⍴⍳9" #3A(((1 2 3 4)) ((5 6 7 8)) ((9 1 2 3))))
 		       (is ",[2.5]3 4⍴⍳9" #3A(((1) (2) (3) (4)) ((5) (6) (7) (8)) ((9) (1) (2) (3))))
 		       (is ",[1 2]2 3 3⍴⍳12" #2A((1 2 3) (4 5 6) (7 8 9) (10 11 12) (1 2 3) (4 5 6)))
 		       (is ",[2 3]2 3 3⍴⍳12" #2A((1 2 3 4 5 6 7 8 9) (10 11 12 1 2 3 4 5 6)))
 		       (is ",[1 2 3]2 3 3⍴⍳12" #(1 2 3 4 5 6 7 8 9 10 11 12 1 2 3 4 5 6))
		       (is "0,3 4⍴⍳9" #2A((0 1 2 3 4) (0 5 6 7 8) (0 9 1 2 3)))
		       (is "0,[1]3 4⍴⍳9" #2A((0 0 0 0) (1 2 3 4) (5 6 7 8) (9 1 2 3)))
 	    	       (is "(3 6⍴⍳6),3 4⍴⍳9" #2A((1 2 3 4 5 6 1 2 3 4) (1 2 3 4 5 6 5 6 7 8)
 	    					 (1 2 3 4 5 6 9 1 2 3)))
 		       (is "(5 4⍴⍳6),[1]3 4⍴⍳9" #2A((1 2 3 4) (5 6 1 2) (3 4 5 6) (1 2 3 4)
 						    (5 6 1 2) (1 2 3 4) (5 6 7 8) (9 1 2 3)))
 		       (is "1 2 3,4 5 6" #(1 2 3 4 5 6))
 		       (is "1 2 3,[1]4 5 6" #(1 2 3 4 5 6))
 		       (is "1 2 3 4,[0.5]1 2 3 4" #2A((1 2 3 4) (1 2 3 4)))
 		       (is "1 2 3 4,[1.5]1 2 3 4" #2A((1 1) (2 2) (3 3) (4 4)))
 		       (is "(2 3⍴⍳9),[0.5]2 3⍴⍳9" #3A(((1 2 3) (4 5 6)) ((1 2 3) (4 5 6))))
 		       (is "(2 3⍴⍳9),[2.5]2 3⍴⍳9" #3A(((1 1) (2 2) (3 3)) ((4 4) (5 5) (6 6))))
 		       (is "'UNDER',[0.5]'-'" #2A((#\U #\N #\D #\E #\R) (#\- #\- #\- #\- #\-)))
 		       (is "'HELLO',[1.5]'.'" #2A((#\H #\.) (#\E #\.) (#\L #\.) (#\L #\.) (#\O #\.)))))
     	    (⍪ (has :titles ("Table" "Catenate First"))
 	       (ambivalent (args :any (lambda (omega) (if (vectorp omega)
 	    						  (make-array (list (length omega) 1)
 								      :element-type (element-type omega)
 	    							      :initial-contents
 	    							      (loop for i from 0 to (1- (length omega))
 	    								 collect (list (aref omega i))))
 	    						  (let ((o-dims (dims omega)))
 							    (make-array (list (first o-dims)
 									      (apply #'* (rest o-dims)))
 									:element-type (element-type omega)
 									:displaced-to (copy-array omega))))))
 	    		   (args :any :any :axes
 				 (lambda (omega alpha &optional axes)
				   (if (and (vectorp alpha)
					    (vectorp omega))
 	    				(if (and axes (< 0 (- (aref (first axes) 0)
 							      (of-state (local-idiom april)
									:count-from))))
 					    (error (concatenate
 						    'string "Specified axis is greater than 1, vectors"
 						    " have only one axis along which to catenate."))
 					    (if (and axes (> 0 (- (aref (first axes) 0)
 								  (of-state (local-idiom april)
									    :count-from))))
 						(error (format nil "Specified axis is less than ~a."
 							       (of-state (local-idiom april)
									 :count-from)))
 						(concatenate 'vector alpha omega)))
 	    				(if (or (not axes)
 						(integerp (aref (first axes) 0)))
 					    (let* ((axis (if axes (- (aref (first axes) 0)
								     (of-state (local-idiom april)
									       :count-from))
							     0))
						   (scale-alpha (if (not (is-singleton alpha))
								    alpha (scale-array alpha omega axis)))
						   (scale-omega (if (not (is-singleton omega))
								    omega (scale-array omega alpha axis))))
					      (aops:stack axis scale-alpha scale-omega)))))))
 	       (tests (is "⍪'MAKE'" #2A((#\M) (#\A) (#\K) (#\E)))
 		      (is "⍪3 4⍴⍳9" #2A((1 2 3 4) (5 6 7 8) (9 1 2 3)))
 		      (is "⍪2 3 4⍴⍳24" #2A((1 2 3 4 5 6 7 8 9 10 11 12)
 					   (13 14 15 16 17 18 19 20 21 22 23 24)))
		      (is "0⍪3 4⍴⍳9" #2A((0 0 0 0) (1 2 3 4) (5 6 7 8) (9 1 2 3)))
		      (is "0⍪[2]3 4⍴⍳9" #2A((0 1 2 3 4) (0 5 6 7 8) (0 9 1 2 3)))
 	    	      (is "(5 4⍴⍳6)⍪3 4⍴⍳9" #2A((1 2 3 4) (5 6 1 2) (3 4 5 6) (1 2 3 4)
 	    					(5 6 1 2) (1 2 3 4) (5 6 7 8) (9 1 2 3)))
 		      (is "(3 6⍴⍳6)⍪[2]3 4⍴⍳9" #2A((1 2 3 4 5 6 1 2 3 4) (1 2 3 4 5 6 5 6 7 8)
 						   (1 2 3 4 5 6 9 1 2 3)))))
 	    (/ (has :title "Replicate")
 	       (dyadic (args :any :any :axes
 	    		     (lambda (omega alpha &optional axes)
 	    		       (expand-array (array-to-list alpha)
 	    				     omega (if axes (- (rank omega)
 	    						       (- (aref (first axes) 0)
 	    							  (1- (of-state (local-idiom april)
										:count-from)))))
 	    				     0 :compress-mode t))))
 	       (tests (is "5/3" #(3 3 3 3 3))
 		      (is "1 0 1 0 1/⍳5" #(1 3 5))
 		      (is "3/⍳5" #(1 1 1))
 		      (is "3/⊂⍳5" #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))
 	    	      (is "1 ¯2 3 ¯4 5/3 5⍴⍳5" #2A((1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
 						   (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
 						   (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)))
 		      (is "1 ¯2 3/[1]3 5⍴⍳9" #2A((1 2 3 4 5) (0 0 0 0 0) (0 0 0 0 0)
 						 (2 3 4 5 6) (2 3 4 5 6) (2 3 4 5 6)))))
 	    (⌿ (has :title "Replicate First")
 	       (dyadic (args :any :any :axes
 	    		     (lambda (omega alpha &optional axes)
 	    		       (expand-array (array-to-list alpha)
 	    				     omega (if axes (- (rank omega)
 	    						       (- (aref (first axes) 0)
 	    							  (1- (of-state (local-idiom april)
										:count-from)))))
 	    				     (1- (rank omega))
 	    				     :compress-mode t))))
 	       (tests (is "1 0 1 0 1⌿⍳5" #(1 3 5))
 		      (is "1 ¯2 3⌿3 5⍴⍳9" #2A((1 2 3 4 5) (0 0 0 0 0) (0 0 0 0 0)
 					      (2 3 4 5 6) (2 3 4 5 6) (2 3 4 5 6)))
 		      (is "1 ¯2 3 ¯4 5⌿[2]3 5⍴⍳5" #2A((1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
 						      (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
 						      (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)))))
 	    (\\ (has :title "Expand")
 	    	(dyadic (args :any :any :axes
 	    		      (lambda (omega alpha &optional axes)
 	    			(expand-array (array-to-list alpha)
 	    				      omega (if axes (- (rank omega)
 	    							(- (aref (first axes) 0)
 	    							   (1- (of-state (local-idiom april)
										 :count-from)))))
 	    				      0))))
 		(tests (is "1 ¯2 3 ¯4 5\\ '.'" ".  ...    .....")
 		       (is "1 ¯2 2 0 1\\3+2 3⍴⍳6" #2A((4 0 0 5 5 0 6) (7 0 0 8 8 0 9)))
 		       (is "1 0 1\\[1]3+2 3⍴⍳6" #2A((4 5 6) (0 0 0) (7 8 9)))))
 	    (⍀ (has :title "Expand First")
 	       (dyadic (args :any :any :axes
 	    		     (lambda (omega alpha &optional axes)
 	    		       (expand-array (array-to-list alpha)
 	    				     omega (if axes (- (rank omega)
 	    						       (- (aref (first axes) 0)
 	    							  (1- (of-state (local-idiom april)
										:count-from)))))
 	    				     (1- (rank omega))))))
 	       (tests (is "1 ¯2 3 ¯4 5⍀3" #(3 0 0 3 3 3 0 0 0 0 3 3 3 3 3))
 		      (is "1 0 1⍀3+2 3⍴⍳6" #2A((4 5 6) (0 0 0) (7 8 9)))))
 	    (⊂ (has :titles ("Enclose" "Partition"))
 	       (ambivalent (args :any :axes
 				 (lambda (omega &optional axes)
 				   (if axes
 				       (re-enclose omega (aops:each (lambda (axel)
 								      (- axel (of-state (local-idiom april)
											:count-from)))
 								    (first axes)))
 				       (if (loop for dim in (dims omega) always (= 1 dim))
 					   omega (make-array (list 1) :initial-element omega)))))
 	    		   (args :any :any (lambda (omega alpha)
 	    				     (if (/= (length alpha) (length omega))
 	    					 (error "Length mismatch.")
 	    					 (let ((output nil)
 	    					       (accumulator nil)
 	    					       (partition-index 0))
 	    					   (dotimes (index (length alpha))
 	    					     (if (and (< 0 index)
 	    						      (< partition-index (aref alpha index)))
 	    						 (progn (setq output
 	    							      (cons (make-array (list (length accumulator))
 	    										:initial-contents
 	    										(reverse accumulator))
 	    								    output))
 	    							(setq accumulator nil)))
 	    					     (setq partition-index (aref alpha index))
 	    					     (if (< 0 (aref alpha index))
 	    						 (setq accumulator (cons (aref omega index)
 	    									 accumulator))))
 	    					   (if accumulator (setq output
 	    								 (cons (make-array
 	    									(list (length accumulator))
 	    									:initial-contents
 	    									(reverse accumulator))
 	    								       output)))
 	    					   (make-array (list (length output))
 	    						       :initial-contents (reverse output)))))))
 	       (tests (is "1,⊂3 4⍴⍳7" #(1 #2A((1 2 3 4) (5 6 7 1) (2 3 4 5))))
 		      (is "⊂[3]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
 			  #2A(("GRAY" "GOLD" "BLUE") ("SILK" "WOOL" "YARN")))
 		      (is "⊂[2]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
 			  #2A(("GGB" "ROL" "ALU" "YDE") ("SWY" "IOA" "LOR" "KLN")))
 		      (is "⊂[1]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
 			  #2A(("GS" "RI" "AL" "YK") ("GW" "OO" "LO" "DL") ("BY" "LA" "UR" "EN")))
 		      (is "⊂[2 3]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
 			  #(#2A((#\G #\R #\A #\Y) (#\G #\O #\L #\D) (#\B #\L #\U #\E))
 			    #2A((#\S #\I #\L #\K) (#\W #\O #\O #\L) (#\Y #\A #\R #\N))))
 		      (is "⊂[1 3]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
 			  #(#2A((#\G #\R #\A #\Y) (#\S #\I #\L #\K))
 			    #2A((#\G #\O #\L #\D) (#\W #\O #\O #\L))
 			    #2A((#\B #\L #\U #\E) (#\Y #\A #\R #\N))))
 		      (is "⊂[1 2]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
 			  #(#2A((#\G #\G #\B) (#\S #\W #\Y)) #2A((#\R #\O #\L) (#\I #\O #\A))
 			    #2A((#\A #\L #\U) (#\L #\O #\R)) #2A((#\Y #\D #\E) (#\K #\L #\N))))
 	    	      (is "1 1 2 2 2 3 3 3 3⊂⍳9" #(#(1 2) #(3 4 5) #(6 7 8 9)))))
 	    (⍧ (has :title "Partitioned Enclose")
 	       (dyadic (args :any :any :axes
 			     (lambda (omega alpha &optional axes)
 			       (partitioned-enclose alpha omega
 						    (if axes (- (rank omega)
 								(- (aref (first axes) 0)
 								   (1- (of-state (local-idiom april)
										 :count-from)))))
 						    0))))
 	       (tests (is "0 1 0 0 1 1 0 0 0⍧⍳9" #(#(2 3 4) #(5) #(6 7 8 9)))
 		      (is "0 1 0 0 1 1 0 0 0⍧4 8⍴⍳9"
 			  #(#2A((2 3 4) (1 2 3) (9 1 2) (8 9 1)) #2A((5) (4) (3) (2))
 			    #2A((6 7 8) (5 6 7) (4 5 6) (3 4 5))))
 		      (is "0 1 0 1 0⍧[1]4 8⍴⍳9"
 			  #(#2A((9 1 2 3 4 5 6 7) (8 9 1 2 3 4 5 6)) #2A((7 8 9 1 2 3 4 5))))))
 	    (⊃ (has :titles ("Mix" "Pick"))
 	       (ambivalent (args :any :axes
 				 (lambda (omega &optional axes)
 				   (mix-arrays (if axes (ceiling (- (1+ (rank omega))
 								    (aref (first axes) 0)
 								    (of-state (local-idiom april)
									      :count-from)))
 						   0)
 					       omega)))
 	    		   (args :any :any (lambda (omega alpha)
 					     (labels ((layer-index (object indices)
 							(if indices
 							    (layer-index (aref object (- (first indices)
 											 (of-state (local-idiom
												    april)
 												   :count-from)))
 									 (rest indices))
 							    object)))
 					       (let ((found (layer-index omega (array-to-list alpha))))
 						 (if (arrayp found)
 						     found (make-array (list 1)
 								       :element-type (element-type omega)
 								       :initial-element found)))))))
 	       (tests (is "⊃(1)(1 2)(1 2 3)" #2A((1 0 0) (1 2 0) (1 2 3)))
 		      (is "⊃[0.5](1)(1 2)(1 2 3)" #2A((1 1 1) (0 2 2) (0 0 3)))
 		      (is "⊃(2 3⍴⍳5)(4 2⍴⍳8)" #3A(((1 2 3) (4 5 1) (0 0 0) (0 0 0))
 						  ((1 2 0) (3 4 0) (5 6 0) (7 8 0))))
 		      (is "⊃[0.5](2 3⍴⍳5)(4 2⍴⍳8)" #3A(((1 4 0 0) (1 3 5 7)) ((2 5 0 0) (2 4 6 8))
 						       ((3 1 0 0) (0 0 0 0))))
 		      (is "⊃[1.5](2 3⍴⍳5)(4 2⍴⍳8)" #3A(((1 2 3) (4 5 1) (0 0 0) (0 0 0))
 						       ((1 2 0) (3 4 0) (5 6 0) (7 8 0))))
 		      (is "⊃2 2 2⍴(1)(1 2)(3 4)(1 2 3)" #4A((((1 0 0) (1 2 0)) ((3 4 0) (1 2 3)))
 							    (((1 0 0) (1 2 0)) ((3 4 0) (1 2 3)))))
 		      (is "2⊃(1 2 3)(4 5 6)(7 8 9)" #(4 5 6))
 		      (is "(2 2)⊃(1 2 3)(4 5 6)(7 8 9)" 5)))
 	    (∪ (has :titles ("Unique" "Union"))
 	       (ambivalent (args :any (lambda (omega)
 	    				(if (not (vectorp omega))
 	    				    (error "Argument must be a vector.")
 	    				    (let ((uniques nil))
 	    				      (dotimes (index (length omega))
 	    					(if (not (find (aref omega index)
 	    						       uniques :test #'array-compare))
 	    					    (setq uniques (cons (aref omega index)
 	    								uniques))))
 	    				      (make-array (list (length uniques))
 							  :element-type (element-type omega)
 	    						  :initial-contents (reverse uniques))))))
 	    		   (args :any :any (lambda (omega alpha)
 	    				     (if (or (not (vectorp alpha))
 	    					     (not (vectorp omega)))
 	    					 (error "Arguments must be vectors.")
 	    					 (let ((uniques nil)
 						       (is-string (and (eql 'character (element-type alpha))
 								       (eql 'character (element-type omega)))))
 	    					   (dotimes (index (length omega))
 	    					     (if (not (find (aref omega index)
 	    							    alpha :test #'array-compare))
 	    						 (setq uniques (cons (aref omega index)
 	    								     uniques))))
 	    					   (concatenate (if is-string 'string 'vector)
 								alpha
 	    							(make-array (list (length uniques))
 									    :element-type (if is-string
 											      'character t)
 	    								    :initial-contents
 	    								    (reverse uniques))))))))
 	       (tests (is "∪1 2 3 4 5 1 2 8 9 10 11 7 8 11 12" #(1 2 3 4 5 8 9 10 11 7 12))
 		      (is "∪'MISSISSIPPI'" "MISP")
 		      (is "3 10 14 18 11∪9 4 5 10 8 3" #(3 10 14 18 11 9 4 5 8))
 		      (is "'STEEL'∪'SABER'" "STEELABR")
 		      (is "'APRIL' 'MAY'∪'MAY' 'JUNE'" #("APRIL" "MAY" "JUNE"))))
 	    (∩ (has :title "Intersection")
 	       (dyadic (args :any :any (lambda (omega alpha)
 	    				 (if (or (not (vectorp alpha))
 	    					 (not (vectorp omega)))
 	    				     (error "Arguments must be vectors.")
 	    				     (let ((matches nil)
 						   (is-string (and (eql 'character (element-type alpha))
 								   (eql 'character (element-type omega)))))
 	    				       (dotimes (index (length alpha))
 	    					 (if (find (aref alpha index)
 	    						   omega :test #'array-compare)
 	    					     (setq matches (cons (aref alpha index)
 	    								 matches))))
 	    				       (make-array (list (length matches))
 							   :element-type (if is-string 'character t)
 	    						   :initial-contents (reverse matches)))))))
 	       (tests (is "'MIXTURE'∩'LATER'" "TRE")
 		      (is "'STEEL'∩'SABER'" "SEE")
 		      (is "1 4 8∩⍳5" #(1 4))))
 	    (⌽ (has :titles ("Reverse" "Rotate"))
 	       (ambivalent (args :any :axes (lambda (omega &optional axes)
 	    				      (if (vectorp omega)
 	    					  (let ((new-array (copy-array omega)))
 	    					    (funcall (make-rotator)
 	    						     new-array)
 	    					    new-array)
 	    					  (if (arrayp omega)
 	    					      (apply-marginal (make-rotator)
 	    							      omega (if axes (1- (aref (first axes) 0)))
 	    							      (1- (rank omega)))))))
 	    		   (args :any :one :axes
 	    			 (lambda (omega alpha &optional axes)
 	    			   (if (vectorp omega)
 	    			       (let ((new-array (copy-array omega)))
 	    				 (funcall (make-rotator alpha)
 	    					  new-array)
 	    				 new-array)
 	    			       (if (arrayp omega)
 	    				   (apply-marginal (make-rotator alpha)
 	    						   omega (if axes (1- (aref (first axes) 0)))
 	    						   (1- (rank omega))))))))
 	       (tests (is "⌽1 2 3 4 5" #(5 4 3 2 1))
 	    	      (is "⌽3 4⍴⍳9" #2A((4 3 2 1) (8 7 6 5) (3 2 1 9)))
 	    	      (is "2⌽3 4⍴⍳9" #2A((3 4 1 2) (7 8 5 6) (2 3 9 1)))))
     	    (⊖ (has :titles ("Reverse First" "Rotate First"))
 	       (ambivalent (args :any :axes (lambda (omega &optional axes)
 	    				      (if (vectorp omega)
 	    					  (let ((new-array (copy-array omega)))
 	    					    (funcall (make-rotator)
 	    						     new-array)
 	    					    new-array)
 	    					  (if (arrayp omega)
 	    					      (apply-marginal (make-rotator)
 	    							      omega (if axes (1- (aref (first axes) 0)))
 	    							      0)))))
 	    		   (args :any :one :axes
 	    			 (lambda (omega alpha &optional axes)
 	    			   (if (vectorp omega)
 	    			       (let ((new-array (copy-array omega)))
 	    				 (funcall (make-rotator alpha)
 	    					  new-array)
 	    				 new-array)
 	    			       (if (arrayp omega)
 	    				   (apply-marginal (make-rotator alpha)
 	    						   omega (if axes (1- (aref (first axes) 0)))
 	    						   0))))))
 	       (tests (is "⊖1 2 3 4 5" #(5 4 3 2 1))
 	    	      (is "⊖3 4⍴⍳9" #2A((9 1 2 3) (5 6 7 8) (1 2 3 4)))
 	    	      (is "1⊖3 4⍴⍳9" #2a((5 6 7 8) (9 1 2 3) (1 2 3 4)))))
 	    (⍉ (has :titles ("Transpose" "Permute"))
 	       (ambivalent (args :any (lambda (omega)
 	    				(aops:permute (reverse (alexandria:iota (rank omega)))
 	    					      omega)))
 	    		   (args :any :any (lambda (omega alpha)
 	    				     (aops:permute (mapcar (lambda (i)
 	    							     (- i (of-state (local-idiom april)
										    :count-from)))
 	    							   (array-to-list alpha))
 	    						   omega))))
 	       (tests (is "⍉2 3 4⍴⍳9" #3A(((1 4) (5 8) (9 3)) ((2 5) (6 9) (1 4))
 					  ((3 6) (7 1) (2 5)) ((4 7) (8 2) (3 6))))
 		      (is "1 3 2⍉2 3 4⍴⍳9" #3A(((1 5 9) (2 6 1) (3 7 2) (4 8 3))
 					       ((4 8 3) (5 9 4) (6 1 5) (7 2 6))))))
 	    (⌹ (has :titles ("Matrix Inverse" "Matrix Divide"))
 	       (ambivalent (args :any (lambda (omega)
 	    				(if (and (= 1 (rank omega))
 	    					 (= 1 (length omega)))
 	    				    (/ (disclose omega))
 	    				    (if (< 2 (rank omega))
 						(error "Matrix inversion only works on arrays of rank 2 or 1.")
 						(if (let ((odims (dims omega)))
 						      (and (= 2 (length odims))
 							   (= (first odims) (second odims))))
 						    (invert-matrix omega)
 						    (left-invert-matrix omega))))))
 	    		   (args :any :any (lambda (omega alpha)
 					     (array-inner-product (invert-matrix omega)
 								  alpha (lambda (arg1 arg2)
 									  (apply-scalar-dyadic #'* arg1 arg2))
 								  #'+))))
 	       (tests (is "⌹1 2 3 4" #(1/30 1/15 1/10 2/15))
 		      (is "⌹2 2⍴4 9 8 2" #2A((-1/32 9/64) (1/8 -1/16)))
 		      (is "⌹4 2⍴1 3 ¯4 9" #2A((3/14 -1/14 3/14 -1/14) (2/21 1/42 2/21 1/42)))
 		      (is "35 89 79⌹3 3⍴3 1 4 1 5 9 2 6 5" #(193/90 739/90 229/45))
 		      (is "(3 2⍴1 2 3 6 9 10)⌹3 3⍴1 0 0 1 1 0 1 1 1" #2A((1 2) (2 4) (6 4)))))
 	    (⍋ (has :titles ("Grade Up" "Grade Up By"))
 	       (ambivalent (args :any (lambda (omega) (grade omega (alpha-compare (of-state (local-idiom april)
 	    										    :atomic-vector)
 	    									  #'<=)
 							     (of-state (local-idiom april)
								       :count-from))))
 	    		   (args :any :any (lambda (omega alpha) (grade (if (vectorp alpha)
 									    (index-of alpha omega
										      (of-state (local-idiom april)
												:count-from))
 									    (array-grade alpha omega))
 	    								(alpha-compare (of-state (local-idiom
												  april)
 	    											 :atomic-vector)
 	    									       #'<)
 									(of-state (local-idiom april)
										  :count-from)))))
 	       (tests (is "⍋8 3 4 9 1 5 2" #(5 7 2 3 6 1 4))
 		      (is "⍋5 6⍴⍳16" #(1 4 2 5 3))
		      (is "st←'aodjeignwug' ⋄ st[⍋st]" "adeggijnouw")
 		      (is "(2 5⍴'ABCDEabcde')⍋'ACaEed'" #(1 3 2 6 4 5))))
 	    (⍒ (has :titles ("Grade Down" "Grade Down By"))
 	       (ambivalent (args :any (lambda (omega) (grade omega (alpha-compare (of-state (local-idiom april)
 	    										    :atomic-vector)
 	    									  #'>=)
 							     (of-state (local-idiom april)
								       :count-from))))
 	    		   (args :any :any (lambda (omega alpha) (grade (if (vectorp alpha)
 									    (index-of alpha omega
										      (of-state (local-idiom april)
												:count-from))
 									    (array-grade alpha omega))
 	    								(alpha-compare (of-state
											(local-idiom april)
											:atomic-vector)
 	    									       #'>)
 									(of-state (local-idiom april)
										  :count-from)))))
 	       (tests (is "⍒6 1 8 2 4 3 9" #(7 3 1 5 6 4 2))
 		      (is "⍒5 6⍴⍳12" #(2 4 1 3 5))
		      (is "st←'aodjeignwug' ⋄ st[⍒st]" "wuonjiggeda")
 		      (is "(2 5⍴'ABCDEabcde')⍒'ACaEed'" #(5 4 6 2 3 1))))
 	    (⊤ (has :title "Encode")
 	       (dyadic (args :any :any (lambda (omega alpha)
 	    				 (flet ((rebase (bases number)
 	    					  (let ((operand number)
 	    						(last-base 1)
 	    						(base 1)
 	    						(component 1)
 	    						(element nil))
 	    					    (loop for index from (1- (length bases)) downto 0
 	    					       do (setq last-base base
 	    							base (* base (aref bases index))
 	    							component (if (= 0 base)
 	    								      operand
 	    								      (* base
 	    									 (nth-value 1 (floor (/ operand
 	    												base)))))
 	    							operand (- operand component)
 	    							element (/ component last-base))
 	    					       collect element))))
 	    				   (if (= 1 (length omega))
 	    				       (let ((result (rebase alpha (aref omega 0))))
 	    					 (make-array (list (length result))
 	    						     :initial-contents (reverse result)))
 	    				       (aops:permute (list 1 0)
 	    						     (make-array (list (length omega) (length alpha))
 	    								 :initial-contents
 	    								 (mapcar (lambda (item)
 	    									   (reverse (rebase alpha item)))
 	    									 (array-to-list omega)))))))))
 	       (tests (is "1760 3 12⊤82" #(2 0 10))
 		      (is "16 16 16 16⊤100" #(0 0 6 4))
 		      (is "2 2 2 2 2⊤1 2 3 4 5" #2A((0 0 0 0 0) (0 0 0 0 0) (0 0 0 1 1)
 						    (0 1 1 0 0) (1 0 1 0 1)))))
 	    (⊥ (has :title "Decode")
 	       (dyadic (args :any :any (lambda (omega alpha)
 	    				 (flet ((rebase (bases numerators)
 	    					  (let ((result 0)
 	    						(base 1))
 	    					    (loop for index from (1- (length numerators)) downto 0
 	    					       do (incf result (* base (aref numerators index)))
 	    						 (setf base (* base (aref bases index))))
 	    					    result)))
 	    				   (let ((bases (if (= 1 (length alpha))
 	    						    (make-array (list (first (dims omega)))
 	    								:initial-element (aref alpha 0))
 	    						    (if (not (= (length alpha)
 	    								(let ((d-o (dims omega)))
 	    								  (if (= 1 (length d-o))
 	    								      (first d-o)
 	    								      (second d-o)))))
 	    							(error "Base/element length mismatch.")
 	    							alpha))))
 	    				     (if (= 1 (rank omega))
 	    					 (vector (rebase bases omega))
 	    					 (aops:margin (lambda (sub-array) (rebase bases sub-array))
 	    						      omega 0)))))))
 	       (tests (is "10⊥2 6 7 1" 2671)
 		      (is "1760 3 12⊥2 2 5" 101)
 		      (is "1760 3 12⊥3 3⍴1 2 1 5 0 2 2 3 7" #(98 75 67))))
 	    (⍎ (has :title "Evaluate")
 	       (monadic (macro (lambda (meta axes omega)
 				 (declare (ignore meta axes))
 				 `(april ,omega))))
 	       (tests (is "⍎'1+1'" 2)))
 	    (∘ (has :title "Find Outer Product, Not Inner")
	       (symbolic :outer-product-designator)))

 (operators (← (has :title "Assign Result Of")
 	       (lateral (lambda (meta axes right-function)
			  (declare (ignore meta axes))
			  (lambda (meta unused omega alpha)
			    (declare (ignore unused))
			    (if (and (listp alpha)
				     (eql 'aref-eliding (first alpha)))
				(append alpha (list :set `(lambda (item coords)
							    (declare (ignore coords))
							    (funcall (lambda (omega alpha)
								       ,(funcall right-function
										 meta nil 'omega 'alpha))
								     ,omega item))))
				(let ((symbol (if (listp alpha)
						  (second alpha)
						  alpha)))
				  `(setq ,symbol (funcall (lambda (omega alpha)
							    ,(funcall right-function meta nil 'omega 'alpha))
							  ,omega ,alpha)))))))
 	       (tests (is "a←3 2 1 ⋄ a+←5 ⋄ a" #(8 7 6))
 		      (is "a←3 2 1 ⋄ a[2]+←5 ⋄ a" #(3 7 1))))
 	    (/ (has :title "Reduce")
 	       (lateral (lambda (meta axes function)
			  (declare (ignore meta))
			  (over-operator-template axes function
						  :for-vector (lambda (function input)
								(vector (reduce function input)))
						  :for-array (lambda (function input axis)
							       (aops:margin (lambda (s) (reduce function s))
									    input axis)))))
 	       (tests (is "+/1 2 3 4 5" 15)
 	    	      (is "+/3 4⍴⍳12" #(10 26 42))
 	    	      (is "+/[1]3 4⍴⍳12" #(15 18 21 24))
		      (is "fn←{⍺+⍵} ⋄ fn/1 2 3 4 5" 15)
 	    	      (is "⌊10000×{⍺+÷⍵}/40/1" 16180)))
  	    (⌿ (has :title "Reduce First")
 	       (lateral (lambda (meta axes function)
			  (declare (ignore meta))
			  (over-operator-template axes function :first-axis t
						  :for-vector (lambda (function input)
								(vector (reduce function input)))
						  :for-array (lambda (function input axis)
							       (aops:margin (lambda (s) (reduce function s))
									    input axis)))))
 	       (tests (is "+⌿3 4⍴⍳12" #(15 18 21 24))
		      (is "{⍺×⍵+3}⌿3 4⍴⍳12" #(207 330 495 708))
 	    	      (is "+⌿[2]3 4⍴⍳12" #(10 26 42))))
 	    (\\ (has :title "Scan")
		(lateral (lambda (meta axes function)
			   (declare (ignore meta))
			   (over-operator-template axes function
						   :for-vector (lambda (function input)
								 (funcall (make-back-scanner function)
									  input))
						   :for-array (lambda (function input axis)
								(apply-marginal (make-back-scanner function)
										input axis (1- (rank input)))))))
 	    	(tests (is "+\\1 2 3 4 5" #(1 3 6 10 15))
 	    	       (is "+\\3 4⍴⍳12" #2A((1 3 6 10) (5 11 18 26) (9 19 30 42)))
 	    	       (is "+\\[1]3 4⍴⍳12" #2A((1 2 3 4) (6 8 10 12) (15 18 21 24)))))
 	    (⍀ (has :title "Scan First")
 	       (lateral (lambda (meta axes function)
			  (declare (ignore meta))
			  (over-operator-template axes function :first-axis t
						  :for-vector (lambda (function input)
								(funcall (make-back-scanner function)
									 input))
						  :for-array (lambda (function input axis)
							       (apply-marginal (make-back-scanner function)
									       input axis (1- (rank input)))))))
 	       (tests (is "+⍀1 2 3 4 5" #(1 3 6 10 15))
 	    	      (is "+⍀3 4⍴⍳12" #2A((1 2 3 4) (6 8 10 12) (15 18 21 24)))
		      (is "{⍺×⍵+3}⍀3 4⍴⍳12" #2A((1 2 3 4) (20 30 42 56) (288 450 660 924)))
 	    	      (is "+⍀[2]3 4⍴⍳12" #2A((1 3 6 10) (5 11 18 26) (9 19 30 42)))))
 	    (\. (has :title "Inner/Outer Product")
 	    	(pivotal (lambda (meta axes left-operand)
			   (declare (ignore meta axes))
			   (if (eq :outer-product-designator left-operand)
			       (lambda (meta axes right-function)
				 (declare (ignore meta axes))
				 (lambda (meta unused omega alpha)
				   (declare (ignore unused))
				   (let ((fn-clause (funcall right-function meta nil 'omega 'alpha)))
				     `(if (is-singleton ,omega)
					  (aops:each (lambda (element)
						       (let ((alpha element)
							     (omega (disclose ,omega)))
							 (disclose ,fn-clause)))
						     ,alpha)
					  (let ((inverse (aops:outer (lambda (omega alpha)
								       (let ((omega (enclose omega))
									     (alpha (enclose alpha)))
									 (if (is-singleton omega)
									     ;; swap arguments in case of a
									     ;; singleton omega argument
									     (let ((placeholder alpha))
									       (setq alpha omega
										     omega placeholder)))
									 (disclose ,fn-clause)))
								     ,alpha ,omega)))
					    (if (not (is-singleton ,alpha))
						inverse (aops:permute (reverse (alexandria:iota (rank inverse)))
								      inverse)))))))
			       (lambda (meta axes right-function)
				 (declare (ignore meta axes))
				 (lambda (meta unused omega alpha)
				   (declare (ignore unused))
				   `(if (and (vectorp ,omega)
					     (vectorp ,alpha))
					(make-array (list 1)
						    :initial-element
						    (reduce (lambda (omega alpha)
							      ,(funcall left-operand meta nil 'omega 'alpha))
							    (apply-scalar-dyadic
							     (lambda (omega alpha)
							       ,(funcall right-function meta nil 'omega 'alpha))
							     ,alpha ,omega)))
					(array-inner-product ,alpha ,omega
							     (let ((f1 (lambda (omega alpha)
									 ,(funcall right-function
										   meta nil 'omega 'alpha))))
							       (lambda (arg1 arg2)
								 (if (or (arrayp arg1)
									 (arrayp arg2))
								     (apply-scalar-dyadic f1 arg1 arg2)
								     (funcall f1 arg1 arg2))))
							     (lambda (omega alpha)
							       ,(funcall left-operand
									 meta nil 'omega 'alpha)))))))))
 	    	(tests (is "2+.×3 4 5" 24)
		       (is "2 3 4+.×8 15 21" 145)
 	    	       (is "2 3 4+.×3 3⍴3 1 4 1 5 9 2 6 5" #(17 41 55))
 	    	       (is "(3 3⍴3 1 4 1 5 9 2 6 5)+.×2 3 4" #(25 53 42))
 	    	       (is "4 5 6∘.+20 30 40 50" #2A((24 34 44 54) (25 35 45 55) (26 36 46 56)))
		       (is "1 2 3∘.-1 2 3" #2A((0 -1 -2) (1 0 -1) (2 1 0)))
		       (is "1 2 3∘.⍴1 2 3" #2A((1 2 3) (#(1 1) #(2 2) #(3 3)) (#(1 1 1) #(2 2 2) #(3 3 3))))
		       (is "1 2 3∘.⍴⊂1 2 3" #(1 #(1 2) #(1 2 3)))
		       (is "1 2 3∘.⌽⊂1 2 3" #(#(2 3 1) #(3 1 2) #(1 2 3)))
		       (is "1 2 3∘.⌽[1]⊂4 5 6 7" #(#(5 6 7 4) #(6 7 4 5) #(7 4 5 6)))))
 	    (\¨ (has :title "Each")
 	    	(lateral (lambda (meta axes function)
			   (declare (ignore meta axes))
			   (lambda (meta axes omega &optional alpha)
			     (declare (ignore axes))
			     (let ((index (gensym)))
			       `(let ((new-array (copy-array ,omega)))
				  ,(if alpha
				       `(let ((right-arg ,alpha))
					  (make-array (dims right-arg)
						      :initial-contents
						      (loop :for ,index :from 0 :to (1- (length right-arg))
							 :collect (disclose (funcall
									     (lambda (omega alpha)
									       ,(funcall function
											 meta nil 'omega 'alpha))
									     (aref new-array 0)
									     (vector (aref right-arg ,index)))))))
				       `(aops:each (lambda (item)
						     (disclose (funcall (lambda (omega)
									  ,(funcall function meta nil 'omega))
									item)))
						   new-array)))))))
		(tests (is "⍳¨1 2 3" #(1 #(1 2) #(1 2 3)))
		       (is "1 ¯1⌽¨⊂1 2 3 4 5" #(#(2 3 4 5 1) #(5 1 2 3 4)))))
	    (̈ (has :title "Each") ;; alternative diaeresis character
	      (lateral (lambda (meta axes function)
			 (declare (ignore meta axes))
			 (lambda (meta axes omega &optional alpha)
			   (declare (ignore axes))
			   (let ((index (gensym)))
			     `(let ((new-array (copy-array ,omega)))
				,(if alpha
				     `(let ((right-arg ,alpha))
					(make-array (dims right-arg)
						    :initial-contents
						    (loop :for ,index :from 0 :to (1- (length right-arg))
						       :collect (disclose (funcall
									   (lambda (omega alpha)
									     ,(funcall function meta nil
										       omega 'alpha))
									   (aref new-array 0)
									   (vector (aref right-arg ,index)))))))
				     `(aops:each (lambda (item)
						   (disclose (funcall (lambda (omega)
									,(funcall function meta nil 'omega))
								      item)))
						 new-array))))))))
 	    (⍨ (has :title "Commute")
 	       (lateral (lambda (meta axes function)
			  (declare (ignore meta axes))
			  (lambda (meta axes omega &optional alpha)
			    (funcall function meta axes (if alpha alpha omega)
				     omega))))
 	       (tests (is "5-⍨10" 5)
		      (is "+⍨10" 20)))
 	    (∘ (has :title "Compose")
 	       (pivotal (lambda (meta axes left-operand)
			  (declare (ignore meta axes))
			  (compose-stage left-operand)))
 	       (tests (is "fn←⍴∘⍴ ⋄ fn 2 3 4⍴⍳9" 3)
 	    	      (is "⍴∘⍴2 3 4⍴⍳9" 3)
 	    	      (is "⍴∘⍴∘⍴2 3 4⍴⍳9" 1)
		      (is "(÷∘5) 30" 6)
		      (is "⌊10000×(+∘*∘0.5)4 16 25" #(56487 176487 266487))
		      (is "fn←5∘- ⋄ fn 2" 3)
		      (is "⌊(0.5∘+∘*)5 8 12" #(148 2981 162755))
 	    	      (is "⌊10000×+∘÷/40/1" 16180)
		      (is "+/∘⍳¨2 5 8" #(3 15 36))))
 	    (⍣ (has :title "Power")
 	       (pivotal (lambda (meta axes left-function)
			  (declare (ignore meta axes))
			  (lambda (meta axes right-operand)
			    (declare (ignore axes))
			    (cond ((and (listp right-operand)
					(not (eql 'lambda (first right-operand))))
				   (let ((arg (gensym))
					 (index (gensym)))
				     `(lambda (omega &optional alpha)
					(declare (ignorable alpha))
					(let ((,arg (disclose omega)))
					  (loop :for ,index :from 0 :to (1- (disclose ,right-operand))
					     :do (setq ,arg (enclose ,(funcall left-function meta nil arg))))
					  ,arg))))
				  ((listp right-operand)
				   (let ((arg (gensym))
					 (prior-arg (gensym)))
				     `(lambda (omega &optional alpha)
					(declare (ignorable alpha))
					(let ((,arg omega)
					      (,prior-arg omega))
					  (loop :while (= 0 (funcall ,right-operand ,prior-arg ,arg))
					     :do (setq ,prior-arg ,arg
						       ,arg (enclose ,(funcall left-function meta nil arg))))
					  ,arg))))))))
 	       (tests (is "fn←{2+⍵}⍣3 ⋄ fn 5" 11)
 	    	      (is "({2+⍵}⍣3) 9" 15)
 	    	      (is "fn←{2+⍵}⍣{10<⍺} ⋄ fn 2" 12)
		      (is "fn←{2+⍵}⍣{10<⍵} ⋄ fn 2" 14)))
	    (⍤ (has :title "Rank")
	       (pivotal (lambda (meta axes left-operand)
			  (declare (ignore meta axes))
			  (lambda (meta axes right-operand)
			    (let* ((item (gensym)) (orank (gensym)) (encr (gensym))
				   (at-omega (second right-operand)))
			      `(lambda (omega &optional alpha)
				 (let ((,orank (rank omega)))
				   (if (= ,orank ,at-omega)
				       (vector ,(funcall left-operand meta axes 'omega 'alpha))
				       (let ((,encr (make-array (list ,at-omega)
								:initial-contents
								(iota ,at-omega
								      :start (- ,orank (1- ,at-omega)
										(of-state (local-idiom april)
											  :count-from))))))
					 (mix-arrays 0 (aops:each (lambda (,item)
								    (vector ,(funcall left-operand
										      meta axes item 'alpha)))
								  (re-enclose omega ,encr))
						     :disclose-items t))))))))))
	    (@ (has :title "At")
	       (pivotal (lambda (meta axes left-operand)
			  (declare (ignore meta axes))
			  (lambda (meta axes right-operand)
			    (let* ((index (gensym)) (new-array (gensym)) (mask (gensym)) (alpha-var (gensym))
				   (omega-var (gensym)) (set (gensym)) (aix (gensym)) (ix (gensym))
				   (item (gensym)) (coords (gensym))
				   (at-omega (cond ((listp right-operand)
						    right-operand)
						   ((functionp right-operand)
						    (funcall right-operand meta axes 'omega))))
				   (at-alpha (cond ((listp left-operand)
						    left-operand)
						   ((or (functionp left-operand)
							(functionp right-operand))
						    (funcall left-operand meta axes 'omega))
						   (t (funcall left-operand meta axes
							       `(let* ((,new-array
									(make-array (list (length ,at-omega))
										    :initial-element nil)))
								  (loop :for ,index :from 0
								     :to (1- (length ,at-omega))
								     :do (setf (aref ,new-array ,index)
									       (aref omega
										     (- (aref ,at-omega ,index)
											(of-state
											 (local-idiom april)
											 :count-from)))))
								  ,new-array)))))
				   (set `(lambda (,item ,coords)
					   (declare (ignore ,item))
					   (if (is-singleton ,alpha-var)
					       (disclose ,alpha-var)
					       (let* ((,ix (if (listp ,index)
							       ,index (list ,index)))
						      (,aix ,(if (functionp left-operand)
								 coords `(append ,ix (nthcdr (length ,ix)
											     ,coords)))))
						 (declare (ignorable ,ix))
						 (disclose (aref-eliding ,alpha-var (if (listp ,aix)
											,aix (list ,aix)))))))))
			      (cond ((functionp right-operand)
				     (lambda (meta axes omega &optional alpha)
				       (declare (ignore omega alpha))
				       (let ((index (gensym)))
					 `(lambda (omega)
					    (let ((,mask ,(funcall right-operand meta axes 'omega)))
					      (loop :for ,index :from 0 :to (1- (length omega))
						 :do (if (/= 0 (aref ,mask ,index))
							 (setf (aref omega ,index)
							       ,(if (functionp left-operand)
								    `(aref ,at-alpha ,index)
								    `(aref ,at-alpha 0)))))
					      omega)))))
				    ((eql 'lambda (first right-operand))
				     `(lambda (omega)
					(let ((,mask (funcall ,right-operand omega)))
					  (loop :for ,index :from 0 :to (1- (length omega))
					     :do (if (/= 0 (aref ,mask ,index))
						     (setf (aref omega ,index)
							   ,(if (functionp left-operand)
								`(aref ,at-alpha ,index)
								`(aref ,at-alpha 0)))))
					  omega)))
				    (t `(lambda (omega)
					  (let* ((,alpha-var ,at-alpha)
						 (,omega-var (apply-scalar-dyadic #'- ,at-omega
										  (of-state (local-idiom april)
											    :count-from))))
					    (loop :for ,index :from 0 :to (1- (length ,omega-var))
					       :do (aref-eliding omega (array-to-list (aref ,omega-var ,index))
								 :set ,set))
					    omega))))))))
	       (tests (is "(20 20@3 8) ⍳9" #(1 2 20 4 5 6 7 20 9))
		      (is "((2 5⍴0 1)@2 5) 5 5⍴⍳9" #2A((1 2 3 4 5) (0 1 0 1 0) (2 3 4 5 6)
						       (7 8 9 1 2) (1 0 1 0 1)))
		      (is "(0@(3∘|)) ⍳9" #(0 0 3 0 0 6 0 0 9))
		      (is "(÷@3 5) ⍳9" #(1 2 1/3 4 1/5 6 7 8 9))
		      (is "({⍵×2}@{⍵>3}) ⍳9" #(1 2 3 8 10 12 14 16 18)))))

 (general-tests (with :title "Basic function definition and use, with comments."
 		      :in ("⍝ This code starts with a comment.
    f1←{⍵+3} ⋄ f2←{⍵×2} ⍝ A comment after the functions are defined.
    ⍝ This is another comment.
    f2 f1 1 2 3 4 5")
 		      :ex #(8 10 12 14 16))
 		(with :title "Monadic inline function."
 		      :in ("{⍵+3} 3 4 5")
 		      :ex #(6 7 8))
 		(with :title "Dyadic inline function."
 		      :in ("1 2 3 {⍺×⍵+3} 3 4 5")
 		      :ex #(6 14 24))
		(with :title "Vector of input variables and discrete values processed within a function."
		      :in ("fn←{3+⍵} ⋄ {fn 8 ⍵} 9")
		      :ex #(11 12))
 		(with :title "Variable-referenced values, including an element within an array, in a vector."
 		      :in ("a←9 ⋄ b←2 3 4⍴⍳9 ⋄ 1 2 a 3 b[1;2;1]")
 		      :ex #(1 2 9 3 5))
		(with :title "Application of functions to indexed array elements."
		      :in ("g←2 3 4 5 ⋄ 9,g[2],3 4")
		      :ex #(9 3 3 4))
 		(with :title "Assignment of an element within an array."
 		      :in ("a←2 3⍴⍳9 ⋄ a[1;2]←20 ⋄ a")
 		      :ex #2A((1 20 3) (4 5 6)))
 		(with :title "Selection from an array with multiple elided dimensions."
 		      :in ("(2 3 3 4 5⍴⍳9)[2;;3;;2]")
 		      :ex #2A((6 2 7 3) (3 8 4 9) (9 5 1 6)))
 		(with :title "Elided assignment."
 		      :in ("a←2 3 4⍴⍳9 ⋄ a[2;;3]←0 ⋄ a")
 		      :ex #3A(((1 2 3 4) (5 6 7 8) (9 1 2 3)) ((4 5 0 7) (8 9 0 2) (3 4 0 6))))
 		(with :title "Elided assignment of applied function's results."
 		      :in ("a←2 3 4⍴⍳9 ⋄ a[2;;3]+←10 ⋄ a")
 		      :ex #3A(((1 2 3 4) (5 6 7 8) (9 1 2 3)) ((4 5 16 7) (8 9 11 2) (3 4 15 6))))
		(with :title "Elision and indexed array elements."
		      :in ("(6 8⍴⍳9)[1 4;]")
		      :ex #2A((1 2 3 4 5 6 7 8) (7 8 9 1 2 3 4 5)))
		(with :title "As above but more complex."
		      :in ("(6 8 5⍴⍳9)[1 4;;2 1]")
		      :ex #3A(((2 1) (7 6) (3 2) (8 7) (4 3) (9 8) (5 4) (1 9))
			      ((5 4) (1 9) (6 5) (2 1) (7 6) (3 2) (8 7) (4 3))))
		(with :title "Indices of indices."
		      :in ("(6 8 5⍴⍳9)[1 4;;2 1][1;2 4 5;]")
		      :ex #2A((7 6) (8 7) (4 3)))
		(with :title "Operation over portions of an array."
		      :in ("a←4 8⍴⍳9 ⋄ a[2 4;1 6 7 8]+←10 ⋄ a")
		      :ex #2A((1 2 3 4 5 6 7 8) (19 1 2 3 4 15 16 17)
			      (8 9 1 2 3 4 5 6) (17 8 9 1 2 13 14 15)))))
