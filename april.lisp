 ;;;; april.lisp

(in-package #:april)

(defparameter *circular-functions*
  ;; APL's set of circular functions called using the ○ function with an alpha argument
  (vector (lambda (input) (exp (* input #C(0 1))))
	  (lambda (input) (* input #C(0 1)))
	  #'conjugate #'values (lambda (input) (sqrt (- -1 (* 2 input))))
	  #'atanh #'acosh #'asinh (lambda (input) (* (sqrt (/ (1+ input) (1- input)))
						     (1+ input)))
	  #'atan #'acos #'asin (lambda (input) (sqrt (- 1 (* 2 input))))
	  #'sin #'cos #'tan (lambda (input) (sqrt (1+ (* 2 input))))
	  #'sinh #'cosh #'tanh (lambda (input) (sqrt (- -1 (* 2 input))))
	  #'realpart #'abs #'imagpart #'phase))

(defun array-to-nested-vector (array)
  "Convert an array to a nested vector. Useful for applications such as JSON conversion where multidimensional arrays must be converted to nested vectors."
  (aops:each (lambda (member)
	       (if (and (arrayp member)
			(< 1 (rank member)))
		   (array-to-nested-vector member)
		   member))
	     (aops:split array 1)))

(defun is-singleton (value)
  "Determine whether an array is a singleton, possessing just one member."
  (or (and (atom value)
	   (not (arrayp value)))
      ;; non-array atoms are considered singleton values
      (let ((adims (dims value)))
	(and (= 1 (first adims))
	     (= 1 (length adims))))))

(defmacro normalizing-vector (&rest items)
  (cons 'vector (loop for item in items
		   collect (if (and (listp item)
				    (eql 'disclose-within-vector (first item)))
			       `(disclose ,item)
			       item))))

(defmacro disclose-within-vector (item)
  item)

(defun apply-scalar-monadic (function omega)
  "Apply a scalar function across a single arguments, iterating over multidimensional and nested arrays."
  (if (arrayp omega)
      (labels ((apply-fn (arg) (if (arrayp arg)
				   (aops:each #'apply-fn arg)
				   (funcall function arg))))
	(aops:each #'apply-fn omega))
      (funcall function omega)))

(defun apply-scalar-dyadic (function alpha omega)
  "Apply a scalar function across objects as appropriate in APL. Handles scalars as well as nested and multidimensional arrays."
  (let* ((alpha-scalar? (not (arrayp alpha)))
	 (omega-scalar? (not (arrayp omega)))
	 (alpha-unitary? (and (not alpha-scalar?)
			      (vectorp alpha)
			      (= 1 (length alpha))))
	 (omega-unitary? (and (not omega-scalar?)
			      (vectorp omega)
			      (= 1 (length omega)))))
    (cond ((and alpha-scalar? omega-scalar?)
	   (funcall function alpha omega))
	  ((and alpha-scalar? omega-unitary?)
	   (aops:each (lambda (alpha omega) (apply-scalar-dyadic function alpha omega))
		      (vector alpha)
		      omega))
	  ((and alpha-unitary? omega-scalar?)
	   (aops:each (lambda (alpha omega) (apply-scalar-dyadic function alpha omega))
		      alpha (vector omega)))
	  ((and alpha-unitary? omega-unitary?)
	   (aops:each (lambda (alpha omega) (apply-scalar-dyadic function alpha omega))
		      alpha omega))
	  ((and (not alpha-unitary?)
		(not omega-unitary?)
		(not alpha-scalar?)
		(not omega-scalar?))
	   (if (loop for dimension in (funcall (lambda (a o) (mapcar #'= a o))
					       (dims alpha)
					       (dims omega))
		  always dimension)
	       (aops:each (lambda (alpha omega) (apply-scalar-dyadic function alpha omega))
			  alpha omega)
	       (error "Array size mismatch.")))
	  (t (labels ((scan-over (element)
			(if (arrayp element)
			    (aops:each #'scan-over element)
			    (apply (lambda (left right) (apply-scalar-dyadic function left right))
				   (cond (alpha-scalar? (list alpha element))
					 (alpha-unitary? (list (aref alpha 0)
							       element))
					 (omega-scalar? (list element omega))
					 (omega-unitary? (list element (aref omega 0))))))))
	       (aops:each #'scan-over (if (or alpha-scalar? alpha-unitary?)
					  omega alpha)))))))

(defun numeric-string-p (string)
  "Checks whether the argument is a numeric string."
  (handler-case (progn (parse-apl-number-string string) t)
    (condition () nil)))

(defun parse-apl-number-string (number-string &optional imaginary-component)
  "Parse an APL numeric string into a Lisp value, handling high minus signs and the J-notation for complex numbers."
  (let ((nstring (string-upcase number-string)))
    (if (and (not imaginary-component)
	     (find #\J nstring))
	(let ((halves (cl-ppcre:split "J" nstring)))
	  (if (and (= 2 (length halves))
		   (< 0 (length (first halves)))
		   (< 0 (length (second halves))))
	      (complex (parse-apl-number-string (first halves) t)
		       (parse-apl-number-string (second halves) t))))
	;; either the macron or combining_macron character may be used as the high minus sign
	(parse-number:parse-number (regex-replace-all "[¯̄]" nstring "-")))))

(defun format-value (idiom-name meta element)
  "Convert a token string into an APL value, paying heed to APL's native ⍺, ⍵ and ⍬ variables."
  (cond ((and (vectorp element)
	      (string= element "⍬"))
	 ;; APL's "zilde" character translates to an empty vector
 	 (make-array (list 0)))
	((and (vectorp element)
	      (or (string= element "⍺")
		  (string= element "⍵")))
	 ;; alpha and omega characters are directly changed to symbols
 	 (intern element idiom-name))
	((numeric-string-p element)
	 (parse-apl-number-string element))
	((or (and (char= #\" (aref element 0))
		  (char= #\" (aref element (1- (length element)))))
	     (and (char= #\' (aref element 0))
		  (char= #\' (aref element (1- (length element))))))
	 ;; strings are converted to Lisp strings and passed through
	 (subseq element 1 (1- (length element))))
	((stringp element)
	 ;; variable references are converted into generated symbols from the variable table or,
	 ;; if no reference is found in that table, a new reference is created there and a new symbol
	 ;; is generated
	 (if (not (gethash :variables meta))
	     (setf (gethash :variables meta)
		   (make-hash-table :test #'eq)))
	 (let ((variable-found (gethash (intern element "KEYWORD")
					(gethash :variables meta))))
	   (if variable-found variable-found
	       ;; create a new variable if no variable is found matching the string
	       (setf (gethash (intern element "KEYWORD")
			      (gethash :variables meta))
		     (gensym)))))
	(t element)))

(defun format-array (values)
  "Format an APL array, passing through values that are already arrays."
  (if (or (stringp (first values))
	  (symbolp (first values))
	  (and (not (second values))
	       (or (listp (first values))
		   (functionp (first values)))))
      ;; if the first item is a list (i.e. code to generate an array of some kind),
      ;; pass it through with no changes. Also pass through strings, which are already arrays,
      ;; any symbols
      (first values)
      `(make-array (list ,(length values))
		   :initial-contents (list ,@values))))

(defun format-function (idiom-name content)
  "Format an APL function, reversing the order of alpha and omega arguments to reflect the argument order of Lisp as opposed to APL."
  (let ((⍺ (intern "⍺" idiom-name))
	(⍵ (intern "⍵" idiom-name)))
    (lambda (meta axes omega &optional alpha)
      (declare (ignorable meta axes))
      `(funcall (lambda (,⍵ &optional ,⍺)
		  (declare (ignorable ,⍺ ,⍵))
		  ,content)
		;; note: enclosing the arguments slows performance when iterating over many values,
		;; but there is no other simple way to ensure the arguments received are arrays
		(enclose ,(macroexpand omega))
		,@(if alpha (list (list 'enclose (macroexpand alpha))))))))

(defun enclose (item)
  "Enclose non-array values, passing through arguments that are already arrays."
  (if (arrayp item)
      item (vector item)))

(defun process-output-vector (items)
  "Process items in a vector to be generated by the compiler, wrapping any array references in aplSymbol so that they are disclosed. This does not apply if the output vector is unitary (length 1)."
  (loop for item in items collect (if (and (< 1 (length items))
					   (listp item)
					   (eql 'aref-eliding (first item)))
				      (list 'disclose item)
				      item)))

;; (sum-until ((omega-value :as #'value)
;; 	    (function :as (function ⍳))
;; 	    (operator :as (operator /))
;; 	    (function :as (function +))
;; 	    (:rest))
;; 	   (let ((x (gensym)))
;; 	     `(loop :for ,x :from (of-state (local-idiom april) :count-from)
;; 		 :to ,omega-value summing ,x)))
#||#

(defun extract-axes (process tokens &optional axes)
  ;;(print (list :to tokens))
  (if (and (listp (first tokens))
	   (eq :axes (caar tokens)))
      (extract-axes process (rest tokens)
		    (cons (loop for axis in (cdar tokens)
			     collect (multiple-value-bind (item item-props remaining)
					 (funcall process axis)
				       ;; allow either a null item (representing an elided axis) or an array
				       (if (or (not item)
					       (eq :array (first (getf item-props :type))))
					   item (error "Invalid axis."))))
			  axes))
      (values axes (first tokens)
	      (rest tokens))))
      
(defun destructure-tokens-array (tokens idiom space properties process)
  (multiple-value-bind (axes this-item remaining)
      (extract-axes process tokens)
    (cond ((and (listp this-item)
		(not (or (eq :fn (first this-item))
			 (eq :op (first this-item)))))
	   (multiple-value-bind (output out-properties)
	       (funcall process this-item)
	     ;; (print (list :pro output out-properties))
	     (if (eq :array (first (getf out-properties :type)))
		 (progn (setf (getf out-properties :type)
			      (cons (first (getf out-properties :type))
				    (cons :enclosed (rest (getf out-properties :type))))
			      (getf out-properties :axes) axes)
			(values output out-properties remaining))
		 (values nil nil tokens))))
	  ((and (numberp this-item)
		(or (not (getf properties :type))
		    (eq :number (first (getf properties :type)))))
	   (if axes (error "Axes cannot be applied to numbers.")
	       (values this-item (list :type (list :array :number))
		       (rest tokens))))
	  ((and (stringp this-item)
		(or (not (getf properties :type))
		    (eq :string (first (getf properties :type)))))
	   (values this-item (list :axes axes :type (list :array :string))
		   remaining))
	  ((and (symbolp this-item)
		(or (eql '⍵ this-item)
		    (eql '⍺ this-item)
		    (getf properties :symbol-overriding)
		    (gethash this-item (gethash :values space))
		    (not (gethash this-item (gethash :functions space))))
		(or (not (getf properties :type))
		    (eq :symbol (first (getf properties :type)))))
	   (values this-item (list :axes axes :type (list :symbol))
		  remaining))
	  (t (values nil nil tokens)))))

(defun destructure-tokens-function (tokens idiom space properties process)
  (multiple-value-bind (axes this-item remaining)
      (extract-axes process tokens)
    ;; (print (list :tt axes))
    (if (listp this-item)
	(if (eq :fn (first this-item))
	    (let ((fn (second this-item)))
	      (cond ((and (characterp fn)
			  (or (not (getf properties :glyph))
			      (and (char= fn (aref (string (getf properties :glyph)) 0)))))
		     ;; (print (list :ggg fn axes))
		     (values fn (list :axes axes :type (list :function :glyph))
			     remaining))
		    ((listp fn)
		     (if axes (error "Axes can only be used with functions represented by symbols.")
			 (values (output-function (funcall process (first fn)))
				 (list :type (list :function :closure))
				 remaining)))
		    (t (values nil nil tokens))))
	    (multiple-value-bind (output out-properties)
		(funcall process this-item)
	      ;; (print (list :fn-enc output out-properties))
	      (if (eq :function (first (getf out-properties :type)))
		  (progn (setf (getf out-properties :type)
			       (cons (first (getf out-properties :type))
				     (cons :enclosed (rest (getf out-properties :type)))))
			 (values output properties remaining))
		  (values nil nil tokens))))
	(let ((fn this-item))
	  ;; (print (list :fff fn (gethash fn (gethash :functions space))
	  ;; 		(gethash fn (gethash :values space))))
	  ;; (print (list :bk fn))
	  (if (and (symbolp fn)
		   (gethash fn (gethash :functions space))
		   (not (gethash fn (gethash :values space))))
	      (values fn (list :type (list :function :referenced))
		      remaining)
	      (values nil nil tokens))))))

(defun destructure-tokens-operator (tokens idiom space properties process)
  (if (and (listp (first tokens))
	   (eq :op (caar tokens)))
      (destructuring-bind (op-type op-symbol)
	  (cdar tokens)
	(let ((valid-by-valence (or (not (getf properties :valence))
				    (eq op-type (getf properties :valence)))))
	  ;;(print (list 11 (cdar tokens) op-type properties (getf properties :valence)))
	  (cond ((and valid-by-valence (getf properties :glyph))
		 (if (char= op-symbol (aref (string (getf properties :glyph)) 0))
		     (values op-symbol (list :type (list :operator op-type))
			     (rest tokens))
		     (values nil nil tokens)))
		(valid-by-valence (values op-symbol (list :type (list :operator op-type)) 
					  (rest tokens)))
		(t (values nil nil tokens)))))))

(defun composer (idiom space tokens &optional precedent properties)
  ;; (print (list :comp tokens precedent properties))
  (if (not tokens)
      (values precedent properties)
      (let ((processed nil))
	;; (print (list :prec precedent))
	;; (print (list :tokens-b precedent tokens))
	(loop :while (not processed)
	   :for pattern :in (if (not precedent)
				(vex::idiom-composer-opening-patterns idiom)
				(vex::idiom-composer-following-patterns idiom))
	   :do ;; (print (list :pattern (getf pattern :name) precedent tokens))
	   (multiple-value-bind (new-processed new-props remaining)
		   (funcall (getf pattern :function)
			    tokens space (lambda (item) (composer idiom space item))
			    precedent properties)
		 ;; (print (list :pr new-processed new-props remaining))
		 (if new-processed (setq processed new-processed properties new-props tokens remaining))))
	(if (not processed)
	    (values precedent properties tokens)
	    (composer idiom space tokens processed properties)))))

(defun build-composer-pattern (sequence idiom tokens-symbol invalid-symbol properties-symbol
			       process space sub-props)
  (labels ((element-check (base-type)
	     `(funcall (gethash ,(intern (string-upcase (cond ((listp base-type)
							       (first base-type))
							      (t base-type)))
	   				 "KEYWORD")
	   			(vex::idiom-composer-primitives ,idiom))
	   	       rem ,(cond ((listp base-type) `(quote ,(rest base-type))))
		       ;; (lambda (item) (composer idiom item))
		       ,process idiom ,space))
	   (process-item (item-symbol item-properties)
	     (let ((multiple (getf item-properties :times))
		   (optional (getf item-properties :optional))
		   (element-type (getf item-properties :element))
		   (pattern-type (getf item-properties :pattern)))
	       (cond (pattern-type
		      `(if (not ,invalid-symbol)
			   (multiple-value-bind (item item-props remaining)
			       ;; (composer ,idiom ,tokens-symbol)
			       (funcall ,process ,tokens-symbol)
			     ;; (print 919)
			     ;; (print (list :composed item item-props remaining ,sub-props))
			     (setq ,sub-props (cons item-props ,sub-props))
			     ;; (setq ,sub-props item-props)
			     (if ,(cond ((getf pattern-type :type)
					 `(loop for type in (list ,@(getf pattern-type :type))
					     always (member type (getf item-props :type))))
					(t t))
				 (setq ,item-symbol item
				       ,tokens-symbol remaining)
				 (setq ,invalid-symbol t)))))
		     (element-type
		      `(if (not ,invalid-symbol)
			   (let ((matching t)
				 (collected nil)
				 (rem ,tokens-symbol)
				 ;; (,sub-props nil)
				 )
			     ;; (print (list :elem rem))
			     (loop ,@(if (eq :any multiple)
					 `(:while (and matching rem))
					 `(:for x from 0 to 0))
				:do (multiple-value-bind (item item-props remaining)
					,(element-check element-type)
				      (setq ,sub-props (cons item-props ,sub-props))
				      ;; (print (list :subs ,sub-props))
				      (if item (setq collected (cons item collected)
						     rem remaining)
					  (setq matching nil))))
			     (if ,(if (not optional)
				      'collected t)
				 (setq ,item-symbol (if (< 1 (length collected))
							collected (first collected))
				       ,tokens-symbol rem)
				 (setq ,invalid-symbol t))
			     (list :out ,item-symbol ,tokens-symbol collected ,optional))))))))
    (loop for item in sequence
       collect (let* ((item-symbol (first item)))
		 (if (keywordp item-symbol)
		     (cond ((eq :with-preceding-type item-symbol)
			    `(setq ,invalid-symbol (loop for item in (getf ,properties-symbol :type)
						      never (eq item ,(second item)))))
			   ((eq :rest item-symbol)
			    `(setq ,invalid-symbol (< 0 (length ,tokens-symbol)))))
		     (let ((item-properties (rest item)))
		       (process-item item-symbol item-properties)))))))

(defmacro set-composer-patterns (name with &rest params)
  (let* ((with (rest with))
	 (idiom (gensym)) (token (gensym)) (invalid (gensym)) (properties (gensym))
	 (space (or (getf with :space-symbol) (gensym)))
	 (precedent-symbol (getf with :precedent-symbol))
	 (precedent (or precedent-symbol (gensym)))
	 (process (or (getf with :process-symbol) (gensym)))
	 (sub-properties (or (getf with :properties-symbol) (gensym)))
	 (idiom-symbol (getf with :idiom-symbol)))
    `(defun ,(intern (string-upcase name)
		     (package-name *package*))
	 (,idiom)
       (let ((,idiom-symbol ,idiom))
	 (setf ,(if precedent-symbol `(vex::idiom-composer-following-patterns ,idiom)
		    `(vex::idiom-composer-opening-patterns ,idiom))
	       (append (list ,@(loop for param in params
				  collect `(list :name ,(intern (string-upcase (first param)) "KEYWORD")
						 :function
						 (lambda (,token ,space ,process &optional ,precedent ,properties)
						   (declare (ignorable ,token ,space ,process
								       ,precedent ,properties))
						   ;; (print (list :it ,token))
						   ;; (print (list :props ,properties))
						   ;; (print (list :prpr ,precedent))
						   (let ((,invalid nil)
							 (,sub-properties nil)
							 ,@(loop for token in (second param)
							      when (not (keywordp (first token)))
							      collect (list (first token) nil)))
						     ;; (print (list :pro ,space ,process))
						     ,@(build-composer-pattern (second param)
									       idiom token invalid
									       properties process space
									       sub-properties)
						     ;; (print (list :inv ,invalid))
						     (setq ,sub-properties (reverse ,sub-properties))
						     ;; reverse the sub-properties since they are
						     ;; consed into the list
						     (if (not ,invalid)
							 (values ,(third param)
								 ,(fourth param)
								 ,token)))))))
		       ,(if precedent `(vex::idiom-composer-following-patterns ,idiom)
			    `(vex::idiom-composer-opening-patterns ,idiom))))))))

(defmacro apl-call (function &rest arguments)
  `(,(if (eql 'scalar-function (first function))
	 (if (= 1 (length arguments))
	     'apply-scalar-monadic 'apply-scalar-dyadic)
	 'funcall)
     ,@(if (and (not (second arguments))
		(listp (first arguments)))
	   (let ((arg-expanded (macroexpand (first arguments))))
	     (if (eql 'apply-scalar-monadic (first arg-expanded))
		 (let ((innerfn (second arg-expanded)))
		   `(,(if (not (eql 'lambda (first innerfn)))
			  (let ((arg (gensym)))
			    `(lambda (,arg) (funcall ,function (funcall ,innerfn ,arg))))
			  (list (first innerfn)
				(second innerfn)
				`(funcall ,function ,(third innerfn))))
		      ,(third arg-expanded)))
		 (list function (first arguments))))
	   (append (list function (first arguments))
		   (if (second arguments)
		       (list (second arguments)))
		   (if (third arguments)
		       (list (third arguments)))))))

(defmacro scalar-function (function)
  (if (symbolp function)
      `(function ,function)
      function))

;; (defmacro call-scalar (fn arg1 &optional arg2)
;;   (if (and (not arg2)
;; 	   (listp arg1))
;;       (let ((arg-expanded (macroexpand arg1)))
;; 	`(apply-scalar-monadic ,@(if (eql 'apply-scalar-monadic (first arg-expanded))
;; 				     (let ((innerfn (second arg-expanded)))
;; 				       `(,(if (not (eql 'lambda (first innerfn)))
;; 					      (let ((arg (gensym)))
;; 						`(lambda (,arg) (funcall ,fn (funcall ,innerfn ,arg))))
;; 					      (list (first innerfn)
;; 						    (second innerfn)
;; 						    `(funcall ,fn ,(third innerfn))))
;; 					 ,(third arg-expanded)))
;; 				     (list fn arg1))))
;;       `(,(if arg2 'apply-scalar-dyadic 'apply-scalar-monadic)
;; 	 ,fn ,(macroexpand arg1)
;; 	 ,@(if arg2 (list (macroexpand arg2))))))

;; (progn ;(print (list :prec precedent operator))
;; 	 `(funcall ,(get-operator-data idiom operator :pivotal)
;; 		   ,function ,precedent))
;; (funcall (get-operator-data idiom operator :pivotal)
;; 	    (if (not (characterp precedent))
;; 		precedent (get-function-data idiom precedent :dyadic))
;; 	    (if (not (characterp operand))
;; 		operand (get-function-data idiom operand :dyadic)))

;; (let ((function-assembler (if (or (functionp function-element)
;; 				    (member :operator-composed (getf (first properties) :type)))
;; 				function-element (assemble-operation idiom function-element))))
;;   ;; (print (list :prop properties))
;;   (if (functionp function-assembler)
;; 	(funcall function-assembler :right-arg precedent :left-arg (output-value value (rest properties))
;; 		 :axes (getf (first properties) :axes))
;; 	`(eval (funcall ,function-assembler :right-arg ,precedent
;; 			:left-arg ,(output-value value (rest properties))
;; 			:axes ,(getf (first properties) :axes)))))

;; (multiple-value-bind (function-object-left format-function-left verify-omega-left verify-alpha-left)
;;     (process-function-spec idiom function nil)
;;   (multiple-value-bind (function-object-right format-function-right verify-omega-right verify-alpha-right)
;; 	(process-function-spec idiom precedent nil)
;;     (process-operator-spec idiom operator function-object-right function-object-left)))

;; (multiple-value-bind (function-object f-function verify-omega verify-alpha)
;;     (process-function-spec idiom function value)
;;   ;; (print (list :f-props properties verify-alpha))
;;   (funcall f-function function-object (funcall verify-omega precedent)
;; 	     (if verify-alpha (funcall verify-alpha value)
;; 		 value)
;; 	     (getf (first properties) :axes)))

;; (multiple-value-bind (function-object f-function verify-omega verify-alpha)
;;     (process-function-spec idiom function value)
;;   (print (list :f-props properties verify-alpha))
;;   (funcall (if (getf (first properties) :function-id)
;; 		 (nth-value 1 (process-function-spec idiom (getf (first properties) :function-id)
;; 						     value))
;; 		 f-function)
;; 	     function-object (funcall verify-omega precedent)
;; 	     (if verify-alpha (funcall verify-alpha value)
;; 		 value)
;; 	     (getf (first properties) :axes)))

(defun process-operator-spec (idiom operator right &optional left)
  ;; (print (list 9999 idiom operator right left))
  (if (member operator (getf (vex::idiom-lexicons idiom) :operators))
      `(funcall ,(gethash operator (getf (vex::idiom-operators-2 idiom)
					 (if (member operator (getf (vex::idiom-lexicons idiom)
								    :lateral-operators))
					     :lateral :pivotal)))
		,right ,@(if left (list left)))))

(defun validate-arg-unitary (value)
  (or (symbolp value)
      (numberp value)
      (and (listp value)
	   (or (not (eql 'vector (first value)))
	       (not (third value))))))

(defun get-function-data (idiom functional-character mode)
  (labels ((find-in-lexicons (character lexicons &optional output)
	     (if (not lexicons)
		 output (find-in-lexicons character (cddr lexicons)
					  (if (member character (second lexicons))
					      (cons (first lexicons)
						    output)
					      output)))))
    (if (characterp functional-character)
	(let ((data (gethash functional-character (getf (vex::idiom-functions-2 idiom) mode))))
	  (if data (values (let ((fn (if (not (eql 'args (first data)))
					 data (first (last data)))))
			     (if (symbolp fn)
				 `(function ,fn)
				 fn))
			   (if (eql 'args (first data))
			       (rest (butlast data 1))
			       (list :scalar :scalar))
			   (find-in-lexicons functional-character (vex::idiom-lexicons idiom)))))
	functional-character)))

(defun get-operator-data (idiom functional-character mode)
  (gethash functional-character (getf (vex::idiom-operators-2 idiom) mode)))

;; (defun assemble-operation (idiom function)
;;   (lambda (&key (right-arg nil) (left-arg nil) (axes nil))
;;     (multiple-value-bind (function-content arg-specs lexicons)
;; 	(get-function-data idiom function (if left-arg :dyadic :monadic))
;;       (let* ((right-unitary (and arg-specs (eq :one (first arg-specs))))
;; 	     (left-unitary (and arg-specs left-arg (eq :one (second arg-specs))))
;; 	     (verify-right (if right-unitary #'validate-arg-unitary (lambda (i) (declare (ignore i)) t)))
;; 	     (verify-left (if left-unitary #'validate-arg-unitary (lambda (i) (declare (ignore i)) t)))
;; 	     (right-arg (if right-unitary `(disclose ,right-arg) right-arg))
;; 	     (left-arg (if left-unitary `(disclose ,left-arg) left-arg)))
;; 	(if (not (funcall verify-right right-arg))
;; 	    (error "Right argument must be unitary.")
;; 	    (if (and left-arg (not (funcall verify-left left-arg)))
;; 		(error "Left argument must be unitary.")
;; 		`(apl-call ,function-content ,right-arg ,@(if left-arg (list left-arg))
;; 			   ,@(if axes `((list ,@(first axes)))))))))))

;; (defun assemble-operation-old (idiom function)
;;   (lambda (&key (right-arg nil) (left-arg nil) (axes nil))
;;     (multiple-value-bind (function-content arg-specs lexicons)
;; 	(get-function-data idiom function (if left-arg :dyadic :monadic))
;;       (let* ((function-type (if (or (and left-arg (member :scalar-dyadic-functions lexicons))
;; 				    (and (not left-arg)
;; 					 (member :scalar-monadic-functions lexicons)))
;; 				:scalar :array))
;; 	     (right-unitary (and arg-specs (eq :one (first arg-specs))))
;; 	     (left-unitary (and arg-specs left-arg (eq :one (second arg-specs))))
;; 	     (verify-right (if right-unitary #'validate-arg-unitary (lambda (i) (declare (ignore i)) t)))
;; 	     (verify-left (if left-unitary #'validate-arg-unitary (lambda (i) (declare (ignore i)) t)))
;; 	     (right-arg (if right-unitary `(disclose ,right-arg) right-arg))
;; 	     (left-arg (if left-unitary `(disclose ,left-arg) left-arg)))
;; 	(if (not (funcall verify-right right-arg))
;; 	    (error "Right argument must be unitary.")
;; 	    (if (and left-arg (not (funcall verify-left left-arg)))
;; 		(error "Left argument must be unitary.")
;; 		`(apl-call ,function-content ,right-arg ,@(if left-arg (list left-arg))
;; 			   ,@(if axes `((list ,@(first axes)))))))))))

;; (defun rev-fun (function)
;;   (lambda (&key (right-arg nil) (left-arg nil) (axes nil))
;;     (funcall (assemble-operation *april-idiom* function)
;; 	     :right-arg left-arg :left-arg right-arg :axes axes)))

(defun enclose-axes (body axis-sets)
  (let ((axes (first axis-sets)))
    (if (not axis-sets)
	body (enclose-axes `(disclose (aref-eliding ,body
						    (mapcar (lambda (vector)
							      (if vector (if (= 1 (length vector))
									     (- (aref vector 0)
										(of-state (local-idiom april)
											  :count-from))
									     (mapcar (lambda (elem)
										       (- elem (of-state
												(local-idiom april)
												:count-from)))
										     (array-to-list vector)))))
							    (list ,@axes))))
			   (rest axis-sets)))))

;; (defun process-function-spec (idiom function value)
;;   (labels ((is-one (value)
;; 	     (if (or (symbolp value)
;; 		     (numberp value)
;; 		     (and (listp value)
;; 			  (or (not (eql 'vector (first value)))
;; 			      (not (third value)))))
;; 		 `(disclose ,value)
;; 		 (error "This argument must be unitary")))
;; 	   (is-any (value) value)
;; 	   ;; (format-value (value)
;; 	   ;;   (if value (if (listp value)
;; 	   ;; 		   `((vector ,@value))
;; 	   ;; 		   `((vector ,value)))))
;; 	   (format-scalar-function (function omega alpha axes)
;; 	     (let ((f-val (output-value alpha)))
;; 	       `(call-scalar ,function ,omega ,@(if f-val (list f-val)) ,@(if axes `((list ,@axes))))))
;; 	   (format-array-function (function omega alpha axes)
;; 	     (let ((f-val (output-value alpha)))
;; 	       `(funcall ,function ,omega ,@(if f-val (list f-val)) ,@(if axes `((list ,@axes)))))))
;;     (let ((f-function #'format-array-function)
;; 	  (function-code (if (and (listp function)
;; 				  (keywordp (first function)))
;; 			     (getf function :function-symbol)
;; 			     function))
;; 	  ;; (function-axes (if (and (listp function)
;; 	  ;; 			  (keywordp (first function)))
;; 	  ;; 		     (getf function :axes)))
;; 	  (verify-omega #'is-any)
;; 	  (verify-alpha #'is-any))
;;       (if (member function (getf (vex::idiom-lexicons idiom) :functions))
;; 	  (let ((function-data (gethash function (getf (vex::idiom-functions-2 idiom)
;; 						       (if value :dyadic :monadic)))))
;; 	    (if (or (member function (getf (vex::idiom-lexicons idiom) (if value :scalar-dyadic-functions
;; 									   :scalar-monadic-functions)))
;; 		    (not (listp function-data))
;; 		    (not (eql 'args (first function-data))))
;; 		(setq f-function #'format-scalar-function
;; 		      function-code function-data)
;; 		(let ((is-dyadic (or (= 4 (length function-data))
;; 				     (and (= 5 (length function-data))
;; 					  (eq :axes (fourth function-data))))))
;; 		  ;; (print (list :fb function-data))
;; 		  (setq verify-omega (if (eq :one (second function-data))
;; 					 #'is-one #'is-any)
;; 			verify-alpha (if is-dyadic (if (eq :one (third function-data))
;; 						       #'is-one #'is-any))
;; 			f-function (if (eq :scalar (third function-data))
;; 				       #'format-scalar-function #'format-array-function)
;; 			function-code (first (last function-data)))))))
;;       (values function-code f-function verify-omega verify-alpha))))

;; (defun output-value (form &optional properties)
;;   (flet ((apply-props (form)
;; 	   (if properties
;; 	       (let ((these-properties properties))
;; 		 ;; (print (list :these form these-properties
;; 		 ;; 	      (first (getf (first these-properties) :axes))))
;; 		 (if (listp form)
;; 		     (loop :for item :in form :collect
;; 			(if (first (getf (first these-properties) :axes))
;; 			    (enclose-axes item (getf (first these-properties) :axes))
;; 			    item)
;; 			:do (setf these-properties (rest these-properties)))
;; 		     (enclose-axes form (getf (first these-properties) :axes))))
;; 	       form)))
;;     (if form (if (listp form)
;; 		 (if (not (or (numberp (first form))
;; 			      (listp (first form))
;; 			      (stringp (first form))
;; 			      (and (symbolp (first form))
;; 				   (not (boundp (first form)))
;; 				   (not (fboundp (first form))))))
;; 		     (apply-props form)
;; 		     `(vector ,@(apply-props form)))
;; 		 (if (not (or (numberp form)
;; 			      (and (symbolp form)
;; 				   (not (boundp form))
;; 				   (not (fboundp form)))))
;; 		     form `(vector ,form))))))

(defun output-value (form &optional properties)
  (flet ((apply-props2 (form form-props)
	   (let ((form-props (if (listp (first form-props))
				 (first form-props)
				 form-props)))
	     ;;(print (list :fff form form-props))
	     (if (getf form-props :axes)
		 (enclose-axes form (getf form-props :axes))
		 form))))
    (let ((axes (mapcar (lambda (item) (getf item :axes))
			properties)))
      ;;(print (list :aa form axes))
      (if form (if (listp form)
		   (if (not (or (numberp (first form))
				(listp (first form))
				(stringp (first form))
				(and (symbolp (first form))
				     (not (find-symbol (string (first form)))))))
		       (if (= 1 (length properties))
			   (apply-props2 form (first properties))
			   (mapcar #'apply-props2 form properties))
		       `(vector ,@(mapcar #'apply-props2 form properties)))
		   (if ;; (not (or (numberp form)
		       ;; 		(and (symbolp form)
		       ;; 		     (not (find-symbol (string form))))))
		       (not (numberp form))
		       (apply-props2 form properties)
		       `(vector ,form)))))))

(defun output-function (form)
  `(lambda (⍵ &optional ⍺)
     (declare (ignorable ⍺))
     ,form))


;; (defun match-value (items)
;;   (if (not (listp (first items)))
;;       (let ((vl (first items)))
;; 	(values vl (rest items)
;; 		(cond ((numberp vl)
;; 		       (list :type (list :number)))
;; 		      ((symbolp vl)
;; 		       (list :type (list :symbol))))))
;;       items))

;; (defun match-function (items)
;;   (if (and (listp (first items))
;; 	   (eq :fn (caar items)))
;;       (let ((fn (cadar items)))
;; 	(values fn (rest items)
;; 		(cond ((characterp fn)
;; 		       (list :type (list :functional-symbol)))
;; 		      ((listp fn)
;; 		       (list :type (list :functional-closure))))))))

;; (match-profile value)

;; (match-profile function)

;; (defmacro match-template (params template)
;;   `(lambda (tokens precedent)
;;      ,@(loop for param in params
;; 	  collect (let* ((sym (first param))
;; 			 (props (rest param))
;; 			 (as (getf props :as))
;; 			 (with (getf props :with)))
;; 		    (cond ((eq :rest sym) nil)
;; 			  ((eq :any with)
;; 			   `(let ((collected nil))
;; 			      (while (funcall ,as (first tokens))
;; 				(setq collected (cons (first tokens)
;; 						      collected)
;; 				      tokens (rest tokens)))
;; 			      (setq ,sym collected)))
;; 			  ((or (not with)
;; 			       (= 1 with))
;; 			   `(setq ,sym (first tokens)
;; 				  tokens (rest tokens))))))
;;      (values ,template
;; 	     tokens)))


(defun left-invert-matrix (in-matrix)
  (let* ((input (if (= 2 (rank in-matrix))
		    in-matrix (make-array (list (length in-matrix) 1)
					  :element-type (element-type in-matrix)
					  :initial-contents (loop for i from 0 to (1- (length in-matrix))
							       collect (list (aref in-matrix i))))))
	 (result (array-inner-product
		  (invert-matrix (array-inner-product (aops:permute (reverse (iota (rank input)))
								    input)
						      input
						      (lambda (arg1 arg2) (apply-scalar-dyadic #'* arg1 arg2))
						      #'+))
		  (aops:permute (reverse (iota (rank input)))
				input)
		  (lambda (arg1 arg2) (apply-scalar-dyadic #'* arg1 arg2))
		  #'+)))
    (if (= 1 (rank in-matrix))
	(aref (aops:split result 1) 0)
	result)))

;; (defun compose-stage (left-operand)
;;   "Perform a stage of function composition for the compose operation (∘)."
;;   (let* ((left-evaluated (if (functionp left-operand)
;; 			     (funcall left-operand nil :marker 'omega 'alpha)
;; 			     left-operand))
;; 	 (functions nil))
;;     (lambda (meta unused right-operand &optional alpha)
;;       (declare (ignore unused alpha))
;;       (cond ((not (functionp right-operand))
;; 	     ;; if the right operand isn't a function, curry accordingly
;; 	     `(lambda (omega)
;; 		(funcall (lambda (omega alpha) ,(funcall left-operand meta nil 'omega 'alpha))
;; 			 ,right-operand omega)))
;; 	    ((not (functionp left-operand))
;; 	     ;; if the left operand isn't a function, curry by building the appropriate function and passing it
;; 	     ;; to the next operation assembly stage if there is no :fun-comp omega value denoting that this is
;; 	     ;; the only stage of assembly
;; 	     (lambda (meta axes omega &optional alpha)
;; 	       (declare (ignore axes alpha))
;; 	       (if (eq :fun-comp omega)
;; 		   `(lambda (omega)
;; 		      (funcall (lambda (omega alpha) ,(funcall right-operand meta nil 'omega 'alpha))
;; 			       omega ,left-operand))
;; 		   (list (lambda (meta axes omega &optional alpha)
;; 			   (declare (ignore axes omega alpha))
;; 			   `(funcall (lambda (omega &optional alpha)
;; 				       ,(funcall right-operand meta nil 'omega 'alpha))
;; 				     omega ,left-operand))))))
;; 	    (t (lambda (meta &optional axes omega alpha)
;; 		 (if (not (eq :fun-comp omega))
;; 		     (setq functions (if (functionp (first left-evaluated))
;; 					 (cons right-operand left-evaluated)
;; 					 (list right-operand left-operand))))
;; 		 ;; note: the alpha-comp and omega-comp variables are enclosed below in case they are passed in as
;; 		 ;; scalars; this causes slowdown when iterating over many values
;; 		 (labels ((wrap (with-alpha fnlist body)
;; 			    (if fnlist
;; 				(wrap with-alpha (rest fnlist)
;; 				      `(funcall (lambda (omega ,@(if (and with-alpha (not (rest fnlist)))
;; 								     (list 'alpha)))
;; 						  ,@(if (and with-alpha (not (rest fnlist)))
;; 							`((declare (ignorable alpha))))
;; 						  ;; alpha is ignorable in the case of a left-curried value
;; 						  ,(if (functionp (first fnlist))
;; 						       (funcall (first fnlist)
;; 								meta nil 'omega
;; 								(if (and with-alpha (not (rest fnlist)))
;; 								    'alpha))
;; 						       (first fnlist)))
;; 						,@(if (and with-alpha (not (rest fnlist)))
;; 						      `((enclose alpha-comp)))
;; 						,body))
;; 				body)))
;; 		   (if (not (eq :marker axes))
;; 		       (funcall (if (eq :fun-comp omega)
;; 				    #'values (lambda (body) `(funcall ,body ,omega ,alpha)))
;; 				`(lambda (omega-comp &optional alpha-comp)
;; 				   (if alpha-comp
;; 				       ,(wrap t (if (functionp (first left-evaluated))
;; 						    left-evaluated (list left-operand))
;; 					      `(funcall (lambda (omega) ,(funcall right-operand meta nil 'omega))
;; 							(enclose omega-comp)))
;; 				       ,(wrap nil (if (functionp (first left-evaluated))
;; 						      left-evaluated
;; 						      (list left-operand))
;; 					      `(funcall (lambda (omega) ,(funcall right-operand meta nil 'omega))
;; 							(enclose omega-comp))))))
;; 		       functions))))))))

(defun over-operator-template (axes function &key (first-axis nil) (for-vector nil) (for-array nil))
  "Build a function to generate code apply functions over arrays, as for APL's reduce and scan operators."
  (lambda (meta unused omega &optional alpha)
    (declare (ignore unused alpha))
    (let ((wrapped-function `(lambda (omega alpha) ,(funcall function meta nil 'omega 'alpha))))
      `(let ((new-array (copy-array ,omega)))
	 (disclose (if (vectorp new-array)
		       (funcall ,for-vector ,wrapped-function new-array)
		       (funcall ,for-array ,wrapped-function new-array
				(if ,axes (1- (aref (first ,axes) 0))
				    ,(if first-axis 0 `(1- (rank new-array)))))))))))

;; (defmacro april-function-glyph-processor (type glyph spec)
;;   (let ((type (intern (string-upcase type) "KEYWORD"))
;; 	(function-type (intern (string-upcase (first spec)) "KEYWORD"))
;; 	(spec-body (rest spec)))
;;     (if (keywordp (first spec-body))
;; 	`(,glyph :lexicons (:functions :scalar-functions :monadic-functions
;; 				       ,@(if (eq :asymmetric-scalar (first spec-body))
;; 					    (list :dyadic-functions)))
;; 		 :functions (,@(if (or (eq :ambivalent function-type)
;; 				       (eq :monadic function-type))
;; 				   (list :monadic (let ((fn (second spec-body)))
;; 						    (if (symbolp fn)
;; 							`(function ,fn)
;; 							fn))))
;; 			       ,@(if (or (eq :ambivalent function-type)
;; 					 (eq :dyadic function-type))
;; 				     (list :dyadic (let ((fn (if (eq :dyadic function-type)
;; 								 (second spec-body)
;; 								 (third spec-body))))
;; 						     (if (symbolp fn)
;; 							 `(function ,fn)
;; 							 fn))))))
;; 	`(,glyph :lexicons (:functions ,@(if (eq :ambivalent function-type)
;; 					     (list :monadic-functions :dyadic-functions)
;; 					     (list (intern (string-upcase (concatenate 'string
;; 										       (string function-type)
;; 										       "-" (string type)))
;; 							   "KEYWORD"))))
;; 		 :functions (,@(if (or (eq :ambivalent function-type)
;; 				       (eq :monadic function-type))
;; 				   (list :monadic (first spec-body)))
;; 			       ,@(if (eq :ambivalent function-type)
;; 				     (list :dyadic (second spec-body))
;; 				     (if (eq :dyadic function-type)
;; 					 (list :dyadic (first spec-body)))))))))


(defmacro april-function-glyph-processor (type glyph spec)
  (let ((type (intern (string-upcase type) "KEYWORD"))
	(function-type (intern (string-upcase (first spec)) "KEYWORD"))
	(spec-body (rest spec)))
    (if (keywordp (first spec-body))
	;; if this is a simple scalar declaration passing through another function
	`(,glyph :lexicons (:functions :scalar-functions :monadic-functions :scalar-monadic-functions
				       ,@(if (not (eq :monadic function-type))
					     (list :dyadic-functions :scalar-dyadic-functions)))
		 :functions (,@(if (or (eq :ambivalent function-type)
				       (eq :monadic function-type))
				   (list :monadic `(scalar-function ,(second spec-body))))
			       ,@(if (or (eq :ambivalent function-type)
					 (eq :dyadic function-type))
				     (list :dyadic `(scalar-function ,(first (last spec-body)))))))
	`(,glyph :lexicons (,@(cond ((eq :functions type)
				     `(:functions ,@(if (eq :ambivalent function-type)
							(list :monadic-functions :dyadic-functions)
							(list (intern (string-upcase
								       (concatenate 'string (string function-type)
										    "-" (string type)))
								      "KEYWORD")))
						  ,@(if (or (and (or (eq :ambivalent function-type)
								     (eq :monadic function-type))
								 (and (eql 'args (caar spec-body))
								      (eq :scalar (cadar spec-body)))))
							(list :scalar-functions :scalar-monadic-functions))
						  ,@(if (or (and (eq :dyadic function-type)
								 (and (eql 'args (caar spec-body))
								      (eq :scalar (cadar spec-body))))
							    (and (eq :ambivalent function-type)
								 (eql 'args (caadr spec-body))
								 (eq :scalar (cadadr spec-body))))
							(list :scalar-functions :scalar-dyadic-functions))))
				    ((eq :operators type)
				     `(:operators ,(if (eq :lateral function-type)
						       :lateral-operators :pivotal-operators)))))
		 ,@(cond ((eq :functions type)
			  `(:functions (,@(if (or (eq :ambivalent function-type)
						  (eq :monadic function-type))
					      (list :monadic (if (and (eql 'args (caar spec-body))
								      (eq :scalar (cadar spec-body)))
								 `(scalar-function ,(caddar spec-body))
								 (first spec-body))))
					  ,@(if (eq :ambivalent function-type)
						(list :dyadic (if (and (eql 'args (caadr spec-body))
								       (eq :scalar (cadadr spec-body)))
								  `(scalar-function ,(third (second spec-body)))
								  (second spec-body)))
						(if (eq :dyadic function-type)
						    (list :dyadic (if (and (eql 'args (caar spec-body))
									   (eq :scalar (cadar spec-body)))
								      `(scalar-function ,(caddar spec-body))
								      (first spec-body))))))))
			 ((eq :operators type)
			  `(:operators ,(first spec-body))))))))

(vex-spec
 april
 (state :count-from 1
	:disclose-output t
	:atomic-vector (concatenate 'string "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ"
				    "[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~¥€⇄∧∼≬⋆⋸⌸⌺⌼⌾⍁¡⍣⍅⎕⍞⌹⍆⍤⍇⍈⍊⊤λ⍍⍏"
				    "£⊥⍶⌶⍐⍑χ≢⍖⍗⍘⍚⍛⌈⍜⍢∪⍨⍕⍎⍬⍪∣│┤⍟∆∇→╣║╗╝←⌊┐└┴┬├─┼↑↓╔╚╩╦╠═╬≡⍸⍷∵⌷⍂⌻⊢⊣⋄┘┌█▄▌▐▀"
				    "⍺⍹⊂⊃⍝⍲⍴⍱⌽⊖○∨⍳⍉∈∩⌿⍀≥≤≠×÷⍙∘⍵⍫⍋⍒¯¨"))
 (utilities :match-blank-character
	    (lambda (char) (member char (list #\  #\Tab)))
	    :match-newline-character
	    (lambda (char) (member char (list #\◊ #\⋄ #\Newline #\Return)))
	    :match-token-character
	    (lambda (char)
	      ;; the ¯ character must be expressed as #\macron to be correctly processed
	      (or (alphanumericp char)
		  (member char (list #\. #\∆ #\⍙ #\¯ #\⍺ #\⍵ #\⍬))))
	    :prep-code-string
	    (lambda (string)
	      ;; this code preprocessor removes comments, including comment-only lines
	      (regex-replace-all (concatenate 'string "^\\s{0,}⍝(.*)[\\r\\n]|(?<=[\\r\\n])\\s{0,}⍝(.*)[\\r\\n]"
					      "|(?<=[\\r\\n])\\s{0,}⍝(.*)[\\r\\n]"
					      "|(?<=[^\\r\\n])\\s{0,}⍝(.*)(?=[\\r\\n])")
				 string ""))
	    :process-axis-string
	    (lambda (string) (cl-ppcre:split #\; string))
	    :format-value #'format-value
	    :format-object #'format-array
	    :format-function #'format-function
	    :mediate-operation-macro 'mediate-operation
	    :assemble-value #'assemble-value
	    ;; :assemble-operation #'assemble-operation
	    :apply-scalar-monadic #'apply-scalar-monadic
	    :apply-scalar-dyadic #'apply-scalar-dyadic
	    :postprocess-compiled
	    (lambda (form)
	      ;; wrap the last element of the compiled output in a disclose form if discloseOutput is set
	      (if (of-state (local-idiom april)
			    :disclose-output)
		  (append (butlast form)
			  (list (list 'disclose (first (last form)))))
		  form))
	    :postprocess-value
	    (lambda (item)
	      (if (of-state (local-idiom april)
			    :disclose-output)
		  (list 'disclose item)
		  item))

	    :process-lexicon-macro 'april-function-glyph-processor
	    )
 (functions (← (has :title "Assign")
	       (dyadic (macro (lambda (meta axes omega alpha)
	    			(declare (ignorable axes))
	    			(if (and (listp alpha)
	    				 (eql 'aref-eliding (first alpha)))
	    			    (append alpha (list :set omega))
	    			    (let ((symbol (if (listp alpha)
	    					      (second alpha)
	    					      alpha)))
	    			      (if (and (listp omega)
					       (or (eql 'lambda (first omega))
						   (and (listp (second omega))
							(eql 'lambda (caadr omega)))))
	    				  ;; assign from either a disclosed or enclosed function definition,
	    				  ;; i.e. a←⍴∘⍴ or a←(⍴∘⍴).
	    				  (setf (gethash symbol (gethash :functions meta))
						omega)
					  (setf (gethash symbol (gethash :values meta))
						omega))
	    			      `(setq ,symbol ,omega))))))
	       (tests (is "x←55 ⋄ x" 55)
	    	      (is "x←2 3 4⍴⍳9 ⋄ x[;1;]←7 ⋄ x" #3A(((7 7 7 7) (5 6 7 8) (9 1 2 3))
	    						  ((7 7 7 7) (8 9 1 2) (3 4 5 6))))))
	    (⊣ (has :titles ("Empty" "Left"))
	       (ambivalent (args :any (lambda (omega)
	    				(declare (ignore omega))
	    				(make-array (list 0))))
	    		   (args :any :any (lambda (omega alpha)
	    				     (declare (ignore omega))
	    				     alpha)))
	       (tests (is "⊣77" #())
		      (is "55⊣77" 55)))
	    (⊢ (has :titles ("Identity" "Right"))
	       (ambivalent (args :any #'identity)
	    		   (args :any :any (lambda (omega alpha)
	    				     (declare (ignore alpha))
	    				     omega)))
	       (tests (is "⊢77" 77)
		      (is "55⊢77" 77)))
	    (+ (has :titles ("Conjugate" "Add"))
	       (ambivalent :asymmetric-scalar conjugate +)
	       (tests (is "+5" 5)
		      (is "+5J2" #C(5 -2))
		      (is "1+1" 2)
		      (is "1+1 2 3" #(2 3 4))))
    	    (- (has :titles ("Negate" "Subtract"))
	       (ambivalent :symmetric-scalar (reverse-op -))
	       (tests (is "2-1" 1)
		      (is "7-2 3 4" #(5 4 3))))
     	    (× (has :titles ("Sign" "Multiply"))
	       (ambivalent :asymmetric-scalar signum *)
	       (tests (is "×20 5 0 ¯5 5 ¯9" #(1 1 0 -1 1 -1))
		      (is "2×3" 6)
		      (is "4 5×8 9" #(32 45))))
     	    (÷ (has :titles ("Reciprocal" "Divide"))
	       (ambivalent :symmetric-scalar (reverse-op /))
	       (tests (is "6÷2" 3)
		      (is "12÷6 3 2" #(2 4 6))
		      (is "÷2 4 8" #(1/2 1/4 1/8))))
     	    (⋆ (has :titles ("Exponential" "Power"))
	       (ambivalent :asymmetric-scalar exp (reverse-op expt))
	       (tests (is "⌊1000×⋆2" 7389)
		      (is "2⋆4" 16)
		      (is "⌊16⋆÷2" 4)))
     	    (* (has :titles ("Exponential" "Power"))
	       (ambivalent :asymmetric-scalar exp (reverse-op expt)))
     	    (⍟ (has :titles ("Natural Logarithm" "Logarithm"))
	       (ambivalent :symmetric-scalar log)
	       (tests (is "⌊1000×⍟5" 1609)
		      (is "⌊2⍟8" 3)))
     	    (\| (has :titles ("Magnitude" "Residue"))
	    	(ambivalent :asymmetric-scalar abs mod)
		(tests (is "|55" 55)
		       (is "|¯33" 33)
		       (is "8|39" 7)))
     	    (! (has :titles ("Factorial" "Binomial"))
	       (ambivalent :asymmetric-scalar sprfact binomial)
	       (tests (is "!5" 120)
		      (is "5!12" 792)))
     	    (⌈ (has :titles ("Ceiling" "Maximum"))
	       (ambivalent :asymmetric-scalar ceiling (reverse-op max))
	       (tests (is "⌈1.0001" 2)
		      (is "⌈1.9998" 2)
		      (is "3⌈0 1 2 3 4 5" #(3 3 3 3 4 5))))
     	    (⌊ (has :titles ("Floor" "Minimum"))
	       (ambivalent :asymmetric-scalar floor (reverse-op min))
	       (tests (is "⌊1.0001" 1)
		      (is "⌊1.9998" 1)
		      (is "3⌊0 1 2 3 4 5" #(0 1 2 3 3 3))))
 	    (? (has :titles ("Random" "Deal"))
 	       (ambivalent (args :scalar (lambda (omega)
 	    				   (+ (random omega)
 	    				      (of-state (local-idiom april)
							:count-from))))
 	    		   (args :one :one (lambda (omega alpha)
					     (let ((omega (disclose omega))
						   (alpha (disclose alpha)))
					       (if (or (not (integerp omega))
						       (not (integerp alpha)))
						   (error "Both arguments to ? must be single integers.")
						   (make-array (list alpha)
							       :initial-contents
							       (loop for i from 0 to (1- alpha)
								  collect (+ (random omega)
									     (of-state (local-idiom april)
										       :count-from))))))))))
     	    (○ (has :titles ("Pi Times" "Circular"))
 	       (ambivalent (args :scalar (lambda (omega) (* pi omega)))
 	    		   (args :any :one
				 (lambda (omega alpha)
				   (let ((alpha (disclose alpha)))
				     (if (not (numberp alpha))
					 (error "The left argument to ○ must be a single number, i.e. 2○10.")
					 ;; the twelfth element of the vector corresponds to
					 ;; index 0, hence an offset of 12 from the vector's first element
					 (apply-scalar-monadic (aref *circular-functions* (+ 12 alpha))
							       omega))))))
 	       (tests (is "⌊100000×○1" 314159)
 		      (is "(⌊1000×1÷2⋆÷2)=⌊1000×1○○÷4" 1)))
 	    (\~ (has :titles ("Not" "Without"))
 	    	(ambivalent (args :scalar (lambda (omega)
					    (cond ((= 0 omega) 1)
						  ((= 1 omega) 0)
						  (t (error "Domain error: arguments to ~ must be 1 or 0.")))))
 	    		    (args :any :any (lambda (omega alpha)
 	    				      (let ((to-exclude (if (stringp omega)
 	    							    (array-to-list omega)
 	    							    (array-to-list (make-array
 	    									    (list (array-total-size omega))
 	    									    :displaced-to omega))))
 	    					    (included nil))
 	    					(aops:each (lambda (element)
 	    						     (if (not (member element to-exclude))
 	    							 (setq included (cons element included))))
 	    						   alpha)
 	    					(make-array (list (length included))
 	    						    :element-type (element-type alpha)
 	    						    :initial-contents (reverse included))))))
 	    	(tests (is "~1 0 1" #(0 1 0))
 	    	       (is "1 2 3 4 5 6 7~3 5" #(1 2 4 6 7))
 	    	       (is "'MACARONI'~'ALFREDO'" "MCNI")))
     	    (< (has :title "Less")
 	       (dyadic (args :scalar (reverse-boolean-op <)))
 	       (tests (is "3<1 2 3 4 5" #(0 0 0 1 1))))
     	    (≤ (has :title "Less or Equal")
 	       (dyadic (args :scalar (reverse-boolean-op <=)))
 	       (tests (is "3≤1 2 3 4 5" #(0 0 1 1 1))))
     	    (= (has :title "Equal")
 	       (dyadic (args :scalar (boolean-op (lambda (omega alpha)
						   (funcall (cond ((and (numberp alpha)
									(numberp omega))
								   #'=)
								  ((and (characterp alpha)
									(characterp omega))
								   #'char=))
							    omega alpha)))))
 	       (tests (is "3=1 2 3 4 5" #(0 0 1 0 0))))
     	    (≥ (has :title "Greater or Equal")
 	       (dyadic (args :scalar (reverse-boolean-op >=)))
 	       (tests (is "3≥1 2 3 4 5" #(1 1 1 0 0))))
     	    (> (has :title "Greater")
 	       (dyadic (args :scalar (reverse-boolean-op >)))
 	       (tests (is "3>1 2 3 4 5" #(1 1 0 0 0))))
     	    (≠ (has :title "Not Equal")
 	       (dyadic (args :scalar (reverse-boolean-op /=)))
 	       (tests (is "3≠1 2 3 4 5" #(1 1 0 1 1))))
 	    (≡ (has :titles ("Depth" "Match"))
 	       (ambivalent (args :any #'array-depth)
 	    		   (args :any :any (reverse-boolean-op array-compare)))
	       (tests (is "≡1 (2 3) (4 5 (6 7)) (8)" 3)))
 	    (≢ (has :titles ("First Dimension" "Not Match"))
 	       (ambivalent (args :any (lambda (omega) (first (dims omega))))
 			   (args :any :any (boolean-op (lambda (omega alpha)
 							 (not (array-compare omega alpha))))))
	       (tests (is "≢1 2 3" 3)
		      (is "≢2 3 4⍴⍳9" 2)))
 	    (^ (has :title "And")
 	       (dyadic (args :scalar (reverse-op lcm))))
 	    (∧ (has :title "And")
 	       (dyadic (args :scalar (reverse-op lcm)))
 	       (tests (is "0 1 0 1 ∧ 0 0 1 1" #(0 0 0 1))))
 	    (⍲ (has :title "Nand")
 	       (dyadic (args :scalar (boolean-op (lambda (omega alpha) (not (= omega alpha 1))))))
 	       (tests (is "0 1 0 1 ⍲ 0 0 1 1" #(1 1 1 0))))
     	    (∨ (has :title "Or")
 	       (dyadic (args :scalar (reverse-op gcd)))
 	       (tests (is "0 1 0 1 ∨ 0 0 1 1" #(0 1 1 1))))
 	    (⍱ (has :title "Nor")
 	       (dyadic (args :scalar (boolean-op (lambda (omega alpha) (= omega alpha 0)))))
 	       (tests (is "0 1 0 1 ⍱ 0 0 1 1" #(1 0 0 0))))
 	    (⍳ (has :titles ("Index" "Index Of"))
 	       (ambivalent (args :one (lambda (omega)
					(let ((omega (disclose omega)))
					  (if (not (integerp omega))
					      (error "The argument to ⍳ must be a single integer, i.e. ⍳9.")
					      (make-array (list omega)
							  :initial-contents
							  (iota omega :start (of-state (local-idiom april)
										       :count-from)))))))
			   (args :any :any (lambda (omega alpha)
					     (index-of omega alpha (of-state (local-idiom april)
									     :count-from)))))
 	       (tests (is "⍳5" #(1 2 3 4 5))
 	    	      (is "3⍳1 2 3 4 5" #(2 2 1 2 2))))
     	    (⍴ (has :titles ("Shape" "Reshape"))
 	       (ambivalent (args :any (lambda (omega)
 					(let ((omega-dims (dims omega)))
 					  (make-array (list (length omega-dims))
 						      :initial-contents omega-dims))))
 	    		   (args :any :any (lambda (omega alpha)
 	    				     (reshape-array-fitting omega (array-to-list alpha)))))
 	       (tests (is "⍴1 2 3" 3)
 		      (is "⍴3 5⍴⍳8" #(3 5))
 		      (is "4 5⍴⍳3" #2A((1 2 3 1 2) (3 1 2 3 1) (2 3 1 2 3) (1 2 3 1 2)))))
 	    (⌷ (has :title "At Axes")
 	       (dyadic (args :any :any :axes
 			     (lambda (omega alpha &optional axes)
 			       (if axes (let ((elided-coords (loop for i from 0 to (1- (rank omega))
								collect nil)))
					  (loop for index from 0 to (1- (length (first axes)))
					     do (setf (nth (- (aref (first axes) index)
							      (of-state (local-idiom april)
									:count-from))
							   elided-coords)
						      (- (aref alpha index)
							 (of-state (local-idiom april)
								   :count-from))))
					  (aref-eliding omega elided-coords))
 				   (let* ((coords (mapcar (lambda (coord) (- coord (of-state (local-idiom april)
											     `:count-from)))
 							  (array-to-list alpha)))
 					  (found (apply #'aref (cons omega coords))))
 				     (if (not (arrayp found))
 					 (vector found)
 					 found))))))
 	       (tests (is "3⌷⍳9" 3)
 		      (is "2 2⌷4 5⍴⍳9" 7)
 		      (is "2 3 4⌷4 5 6⍴⍳9" 1)
 		      (is "1 3⌷[1 2]2 3 4⍴⍳5" #(4 5 1 2))))
 	    (∊ (has :titles ("Enlist" "Membership"))
 	       (ambivalent (args :any #'enlist)
 	    		   (args :any :any (lambda (omega alpha)
 	    				     (let ((output (make-array (dims alpha))))
 	    				       (dotimes (index (array-total-size output))
 	    					 (let ((found nil))
 	    					   (aops:each (lambda (input)
 	    							(cond ((and (numberp input)
 	    								    (numberp (row-major-aref alpha index))
 	    								    (= input (row-major-aref alpha index)))
 	    							       (setq found t))
 	    							      ((and (characterp input)
 	    								    (characterp (row-major-aref alpha
 													index))
 	    								    (char= input
 	    									   (row-major-aref alpha index)))
 	    							       (setq found t))))
 	    						      omega)
 	    					   (setf (row-major-aref output index)
 	    						 (if found 1 0))))
 	    				       output))))
 	       (tests (is "∊2 2 2⍴⍳9" #(1 2 3 4 5 6 7 8))
 	    	      (is "2 5 7∊1 2 3 4 5" #(1 1 0))))
 	    (⍷ (has :title "Find")
 	       (dyadic (args :any :any #'find-array))
 	       (tests (is "(2 2⍴6 7 1 2)⍷2 3 4⍴⍳9" #3A(((0 0 0 0) (0 1 0 0) (0 0 0 0))
 						       ((0 0 1 0) (0 0 0 0) (0 0 0 0))))))
 	    (↑ (has :titles ("Disclose" "Take"))
 	       (ambivalent (args :any (lambda (omega)
 	    				(if (or (not (vectorp omega))
 	    					(not (arrayp (aref omega 0))))
 	    				    omega (aref omega 0))))
 	    		   (args :any :any :axes
 	    			 (lambda (omega alpha &optional axes)
 	    			   (multidim-slice omega (if axes
 							     (loop for axis from 0 to (1- (rank omega))
 								collect (if (= axis (- (aref (first axes) 0)
 										       (of-state
											(local-idiom april)
											:count-from)))
 									    (aref alpha 0)
 									    (nth axis (dims omega))))
 							     (array-to-list alpha))
 	    					   :fill-with 0))))
 	       (tests (is "↑⊂1 2 3 4" #(1 2 3 4))
 	    	      (is "2 3 4↑4 5 6⍴⍳9" #3A(((1 2 3 4) (7 8 9 1) (4 5 6 7))
 	    				       ((4 5 6 7) (1 2 3 4) (7 8 9 1))))
 		      (is "1↑[1]2 3 4⍴⍳9" #3A(((1 2 3 4) (5 6 7 8) (9 1 2 3))))
 		      (is "1↑[2]2 3 4⍴⍳9" #3A(((1 2 3 4)) ((4 5 6 7))))
 		      (is "2↑[2]2 3 4⍴⍳9" #3A(((1 2 3 4) (5 6 7 8)) ((4 5 6 7) (8 9 1 2))))
 		      (is "2↑[3]2 3 4⍴⍳9" #3A(((1 2) (5 6) (9 1)) ((4 5) (8 9) (3 4))))))
 	    (↓ (has :titles ("Split" "Drop"))
 	       (ambivalent (args :any :axes (lambda (omega &optional axes)
 	    				      (aops:split omega (if axes (aref (first axes) 0)
 	    							    (1- (rank omega))))))
 	    		   (args :any :any :axes
 	    			 (lambda (omega alpha &optional axes)
 	    			   (multidim-slice omega
 						   (if axes (loop for axis from 0 to (1- (rank omega))
 							       collect (if (= axis (- (aref (first axes) 0)
 										      (of-state (local-idiom april)
 												:count-from)))
 									   (aref alpha 0)
 									   0))
 						       (array-to-list alpha))
 	    					   :inverse t))))
 	       (tests (is "↓3 4⍴⍳9" #(#(1 2 3 4) #(5 6 7 8) #(9 1 2 3)))
 	    	      (is "2 2 2↓4 5 6⍴⍳9" #3A(((3 4 5 6) (9 1 2 3) (6 7 8 9))
 	    				       ((6 7 8 9) (3 4 5 6) (9 1 2 3))))
 		      (is "1↓[1]2 3 4⍴⍳9" #3A(((4 5 6 7) (8 9 1 2) (3 4 5 6))))
 		      (is "1↓[2]2 3 4⍴⍳9" #3A(((5 6 7 8) (9 1 2 3)) ((8 9 1 2) (3 4 5 6))))
 		      (is "2↓[2]2 3 4⍴⍳9" #3A(((9 1 2 3)) ((3 4 5 6))))
 		      (is "2↓[3]2 3 4⍴⍳9" #3A(((3 4) (7 8) (2 3)) ((6 7) (1 2) (5 6))))
		      (is "¯2↓⍳9" #(1 2 3 4 5 6 7))
		      (is "¯2 ¯2↓5 8⍴⍳9" #2A((1 2 3 4 5 6) (9 1 2 3 4 5) (8 9 1 2 3 4)))))
 	    (\, (has :titles ("Ravel" "Catenate or Laminate"))
 	    	(ambivalent (args :any :axes
 				  (lambda (omega &optional axes)
 				    (ravel (of-state (local-idiom april)
						     :count-from)
 					   omega axes)))
 	    		    (args :any :any :axes
 	    			  (lambda (omega alpha &optional axes)
 	    			    (if (and (or (not axes)
 						 (integerp (aref (first axes) 0)))
 					     (vectorp alpha)
 	    				     (vectorp omega))
 	    				(if (and axes (< 0 (- (aref (first axes) 0)
 							      (of-state (local-idiom april)
									:count-from))))
 					    (error (concatenate
 						    'string "Specified axis is greater than 1, vectors"
 						    " have only one axis along which to catenate."))
 					    (if (and axes (> 0 (- (aref (first axes) 0)
 								  (of-state (local-idiom april)
									    :count-from))))
 						(error (format nil "Specified axis is less than ~a."
 							       (of-state (local-idiom april)
									 :count-from)))
 						(concatenate 'vector alpha omega)))
 	    				(if (or (not axes)
 						(integerp (aref (first axes) 0)))
 					    (let* ((axis (if axes (- (aref (first axes) 0)
								     (of-state (local-idiom april)
									       :count-from))
							     (1- (max (array-rank alpha)
								      (array-rank omega)))))
						   (scale-alpha (if (not (is-singleton alpha))
								    alpha (scale-array alpha omega axis)))
						   (scale-omega (if (not (is-singleton omega))
								    omega (scale-array omega alpha axis))))
					      (aops:stack axis scale-alpha scale-omega))
 					    ;; laminate in the case of a fractional axis argument
 					    (let* ((axis (ceiling (- (aref (first axes) 0)
 								     (of-state (local-idiom april)
									       :count-from))))
 						   (permute-dims (alexandria:iota (1+ (rank alpha))))
 						   (p-alpha (if (not (is-singleton alpha))
 								(aops:permute (rotate-right axis permute-dims)
 									      (array-promote alpha))))
 						   (p-omega (if (not (is-singleton omega))
 								(aops:permute (rotate-right axis permute-dims)
 									      (array-promote omega)))))
 					      ;; a 1-element array argument to laminate is scaled to
 					      ;; match the other array's dimensions
 					      (aops:stack axis (if (is-singleton alpha)
								   (scale-array alpha p-omega)
								   p-alpha)
 							  (if (is-singleton omega)
 							      (scale-array omega p-alpha)
 							      p-omega))))))))
 	    	(tests (is ",3 4⍴⍳9" #(1 2 3 4 5 6 7 8 9 1 2 3))
 		       (is ",[0.5]3 4⍴⍳9" #3A(((1 2 3 4) (5 6 7 8) (9 1 2 3))))
 		       (is ",[1.5]3 4⍴⍳9" #3A(((1 2 3 4)) ((5 6 7 8)) ((9 1 2 3))))
 		       (is ",[2.5]3 4⍴⍳9" #3A(((1) (2) (3) (4)) ((5) (6) (7) (8)) ((9) (1) (2) (3))))
 		       (is ",[1 2]2 3 3⍴⍳12" #2A((1 2 3) (4 5 6) (7 8 9) (10 11 12) (1 2 3) (4 5 6)))
 		       (is ",[2 3]2 3 3⍴⍳12" #2A((1 2 3 4 5 6 7 8 9) (10 11 12 1 2 3 4 5 6)))
 		       (is ",[1 2 3]2 3 3⍴⍳12" #(1 2 3 4 5 6 7 8 9 10 11 12 1 2 3 4 5 6))
		       (is "0,3 4⍴⍳9" #2A((0 1 2 3 4) (0 5 6 7 8) (0 9 1 2 3)))
		       (is "0,[1]3 4⍴⍳9" #2A((0 0 0 0) (1 2 3 4) (5 6 7 8) (9 1 2 3)))
 	    	       (is "(3 6⍴⍳6),3 4⍴⍳9" #2A((1 2 3 4 5 6 1 2 3 4) (1 2 3 4 5 6 5 6 7 8)
 	    					 (1 2 3 4 5 6 9 1 2 3)))
 		       (is "(5 4⍴⍳6),[1]3 4⍴⍳9" #2A((1 2 3 4) (5 6 1 2) (3 4 5 6) (1 2 3 4)
 						    (5 6 1 2) (1 2 3 4) (5 6 7 8) (9 1 2 3)))
 		       (is "1 2 3,4 5 6" #(1 2 3 4 5 6))
 		       (is "1 2 3,[1]4 5 6" #(1 2 3 4 5 6))
 		       (is "1 2 3 4,[0.5]1 2 3 4" #2A((1 2 3 4) (1 2 3 4)))
 		       (is "1 2 3 4,[1.5]1 2 3 4" #2A((1 1) (2 2) (3 3) (4 4)))
 		       (is "(2 3⍴⍳9),[0.5]2 3⍴⍳9" #3A(((1 2 3) (4 5 6)) ((1 2 3) (4 5 6))))
 		       (is "(2 3⍴⍳9),[2.5]2 3⍴⍳9" #3A(((1 1) (2 2) (3 3)) ((4 4) (5 5) (6 6))))
 		       (is "'UNDER',[0.5]'-'" #2A((#\U #\N #\D #\E #\R) (#\- #\- #\- #\- #\-)))
 		       (is "'HELLO',[1.5]'.'" #2A((#\H #\.) (#\E #\.) (#\L #\.) (#\L #\.) (#\O #\.)))))
     	    (⍪ (has :titles ("Table" "Catenate First"))
 	       (ambivalent (args :any (lambda (omega) (if (vectorp omega)
 	    						  (make-array (list (length omega) 1)
 								      :element-type (element-type omega)
 	    							      :initial-contents
 	    							      (loop for i from 0 to (1- (length omega))
 	    								 collect (list (aref omega i))))
 	    						  (let ((o-dims (dims omega)))
 							    (make-array (list (first o-dims)
 									      (apply #'* (rest o-dims)))
 									:element-type (element-type omega)
 									:displaced-to (copy-array omega))))))
 	    		   (args :any :any :axes
 				 (lambda (omega alpha &optional axes)
				   (if (and (vectorp alpha)
					    (vectorp omega))
 	    				(if (and axes (< 0 (- (aref (first axes) 0)
 							      (of-state (local-idiom april)
									:count-from))))
 					    (error (concatenate
 						    'string "Specified axis is greater than 1, vectors"
 						    " have only one axis along which to catenate."))
 					    (if (and axes (> 0 (- (aref (first axes) 0)
 								  (of-state (local-idiom april)
									    :count-from))))
 						(error (format nil "Specified axis is less than ~a."
 							       (of-state (local-idiom april)
									 :count-from)))
 						(concatenate 'vector alpha omega)))
 	    				(if (or (not axes)
 						(integerp (aref (first axes) 0)))
 					    (let* ((axis (if axes (- (aref (first axes) 0)
								     (of-state (local-idiom april)
									       :count-from))
							     0))
						   (scale-alpha (if (not (is-singleton alpha))
								    alpha (scale-array alpha omega axis)))
						   (scale-omega (if (not (is-singleton omega))
								    omega (scale-array omega alpha axis))))
					      (aops:stack axis scale-alpha scale-omega)))))))
 	       (tests (is "⍪'MAKE'" #2A((#\M) (#\A) (#\K) (#\E)))
 		      (is "⍪3 4⍴⍳9" #2A((1 2 3 4) (5 6 7 8) (9 1 2 3)))
 		      (is "⍪2 3 4⍴⍳24" #2A((1 2 3 4 5 6 7 8 9 10 11 12)
 					   (13 14 15 16 17 18 19 20 21 22 23 24)))
		      (is "0⍪3 4⍴⍳9" #2A((0 0 0 0) (1 2 3 4) (5 6 7 8) (9 1 2 3)))
		      (is "0⍪[2]3 4⍴⍳9" #2A((0 1 2 3 4) (0 5 6 7 8) (0 9 1 2 3)))
 	    	      (is "(5 4⍴⍳6)⍪3 4⍴⍳9" #2A((1 2 3 4) (5 6 1 2) (3 4 5 6) (1 2 3 4)
 	    					(5 6 1 2) (1 2 3 4) (5 6 7 8) (9 1 2 3)))
 		      (is "(3 6⍴⍳6)⍪[2]3 4⍴⍳9" #2A((1 2 3 4 5 6 1 2 3 4) (1 2 3 4 5 6 5 6 7 8)
 						   (1 2 3 4 5 6 9 1 2 3)))))
 	    (/ (has :title "Replicate")
 	       (dyadic (args :any :any :axes
 	    		     (lambda (omega alpha &optional axes)
 	    		       (expand-array (array-to-list alpha)
 	    				     omega (if axes (- (rank omega)
 	    						       (- (aref (first axes) 0)
 	    							  (1- (of-state (local-idiom april)
										:count-from)))))
 	    				     0 :compress-mode t))))
 	       (tests (is "5/3" #(3 3 3 3 3))
 		      (is "1 0 1 0 1/⍳5" #(1 3 5))
 		      (is "3/⍳5" #(1 1 1))
 		      (is "3/⊂⍳5" #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))
 	    	      (is "1 ¯2 3 ¯4 5/3 5⍴⍳5" #2A((1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
 						   (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
 						   (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)))
 		      (is "1 ¯2 3/[1]3 5⍴⍳9" #2A((1 2 3 4 5) (0 0 0 0 0) (0 0 0 0 0)
 						 (2 3 4 5 6) (2 3 4 5 6) (2 3 4 5 6)))))
 	    (⌿ (has :title "Replicate First")
 	       (dyadic (args :any :any :axes
 	    		     (lambda (omega alpha &optional axes)
 	    		       (expand-array (array-to-list alpha)
 	    				     omega (if axes (- (rank omega)
 	    						       (- (aref (first axes) 0)
 	    							  (1- (of-state (local-idiom april)
										:count-from)))))
 	    				     (1- (rank omega))
 	    				     :compress-mode t))))
 	       (tests (is "1 0 1 0 1⌿⍳5" #(1 3 5))
 		      (is "1 ¯2 3⌿3 5⍴⍳9" #2A((1 2 3 4 5) (0 0 0 0 0) (0 0 0 0 0)
 					      (2 3 4 5 6) (2 3 4 5 6) (2 3 4 5 6)))
 		      (is "1 ¯2 3 ¯4 5⌿[2]3 5⍴⍳5" #2A((1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
 						      (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
 						      (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)))))
 	    (\\ (has :title "Expand")
 	    	(dyadic (args :any :any :axes
 	    		      (lambda (omega alpha &optional axes)
 	    			(expand-array (array-to-list alpha)
 	    				      omega (if axes (- (rank omega)
 	    							(- (aref (first axes) 0)
 	    							   (1- (of-state (local-idiom april)
										 :count-from)))))
 	    				      0))))
 		(tests (is "1 ¯2 3 ¯4 5\\ '.'" ".  ...    .....")
 		       (is "1 ¯2 2 0 1\\3+2 3⍴⍳6" #2A((4 0 0 5 5 0 6) (7 0 0 8 8 0 9)))
 		       (is "1 0 1\\[1]3+2 3⍴⍳6" #2A((4 5 6) (0 0 0) (7 8 9)))))
 	    (⍀ (has :title "Expand First")
 	       (dyadic (args :any :any :axes
 	    		     (lambda (omega alpha &optional axes)
 	    		       (expand-array (array-to-list alpha)
 	    				     omega (if axes (- (rank omega)
 	    						       (- (aref (first axes) 0)
 	    							  (1- (of-state (local-idiom april)
										:count-from)))))
 	    				     (1- (rank omega))))))
 	       (tests (is "1 ¯2 3 ¯4 5⍀3" #(3 0 0 3 3 3 0 0 0 0 3 3 3 3 3))
 		      (is "1 0 1⍀3+2 3⍴⍳6" #2A((4 5 6) (0 0 0) (7 8 9)))))
 	    (⊂ (has :titles ("Enclose" "Partition"))
 	       (ambivalent (args :any :axes
 				 (lambda (omega &optional axes)
 				   (if axes
 				       (re-enclose omega (aops:each (lambda (axel)
 								      (- axel (of-state (local-idiom april)
											:count-from)))
 								    (first axes)))
 				       (if (loop for dim in (dims omega) always (= 1 dim))
 					   omega (make-array (list 1) :initial-element omega)))))
 	    		   (args :any :any (lambda (omega alpha)
 	    				     (if (/= (length alpha) (length omega))
 	    					 (error "Length mismatch.")
 	    					 (let ((output nil)
 	    					       (accumulator nil)
 	    					       (partition-index 0))
 	    					   (dotimes (index (length alpha))
 	    					     (if (and (< 0 index)
 	    						      (< partition-index (aref alpha index)))
 	    						 (progn (setq output
 	    							      (cons (make-array (list (length accumulator))
 	    										:initial-contents
 	    										(reverse accumulator))
 	    								    output))
 	    							(setq accumulator nil)))
 	    					     (setq partition-index (aref alpha index))
 	    					     (if (< 0 (aref alpha index))
 	    						 (setq accumulator (cons (aref omega index)
 	    									 accumulator))))
 	    					   (if accumulator (setq output
 	    								 (cons (make-array
 	    									(list (length accumulator))
 	    									:initial-contents
 	    									(reverse accumulator))
 	    								       output)))
 	    					   (make-array (list (length output))
 	    						       :initial-contents (reverse output)))))))
 	       (tests (is "1,⊂3 4⍴⍳7" #(1 #2A((1 2 3 4) (5 6 7 1) (2 3 4 5))))
 		      (is "⊂[3]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
 			  #2A(("GRAY" "GOLD" "BLUE") ("SILK" "WOOL" "YARN")))
 		      (is "⊂[2]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
 			  #2A(("GGB" "ROL" "ALU" "YDE") ("SWY" "IOA" "LOR" "KLN")))
 		      (is "⊂[1]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
 			  #2A(("GS" "RI" "AL" "YK") ("GW" "OO" "LO" "DL") ("BY" "LA" "UR" "EN")))
 		      (is "⊂[2 3]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
 			  #(#2A((#\G #\R #\A #\Y) (#\G #\O #\L #\D) (#\B #\L #\U #\E))
 			    #2A((#\S #\I #\L #\K) (#\W #\O #\O #\L) (#\Y #\A #\R #\N))))
 		      (is "⊂[1 3]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
 			  #(#2A((#\G #\R #\A #\Y) (#\S #\I #\L #\K))
 			    #2A((#\G #\O #\L #\D) (#\W #\O #\O #\L))
 			    #2A((#\B #\L #\U #\E) (#\Y #\A #\R #\N))))
 		      (is "⊂[1 2]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
 			  #(#2A((#\G #\G #\B) (#\S #\W #\Y)) #2A((#\R #\O #\L) (#\I #\O #\A))
 			    #2A((#\A #\L #\U) (#\L #\O #\R)) #2A((#\Y #\D #\E) (#\K #\L #\N))))
 	    	      (is "1 1 2 2 2 3 3 3 3⊂⍳9" #(#(1 2) #(3 4 5) #(6 7 8 9)))))
 	    (⍧ (has :title "Partitioned Enclose")
 	       (dyadic (args :any :any :axes
 			     (lambda (omega alpha &optional axes)
 			       (partitioned-enclose alpha omega
 						    (if axes (- (rank omega)
 								(- (aref (first axes) 0)
 								   (1- (of-state (local-idiom april)
										 :count-from)))))
 						    0))))
 	       (tests (is "0 1 0 0 1 1 0 0 0⍧⍳9" #(#(2 3 4) #(5) #(6 7 8 9)))
 		      (is "0 1 0 0 1 1 0 0 0⍧4 8⍴⍳9"
 			  #(#2A((2 3 4) (1 2 3) (9 1 2) (8 9 1)) #2A((5) (4) (3) (2))
 			    #2A((6 7 8) (5 6 7) (4 5 6) (3 4 5))))
 		      (is "0 1 0 1 0⍧[1]4 8⍴⍳9"
 			  #(#2A((9 1 2 3 4 5 6 7) (8 9 1 2 3 4 5 6)) #2A((7 8 9 1 2 3 4 5))))))
 	    (⊃ (has :titles ("Mix" "Pick"))
 	       (ambivalent (args :any :axes
 				 (lambda (omega &optional axes)
 				   (mix-arrays (if axes (ceiling (- (1+ (rank omega))
 								    (aref (first axes) 0)
 								    (of-state (local-idiom april)
									      :count-from)))
 						   0)
 					       omega)))
 	    		   (args :any :any (lambda (omega alpha)
 					     (labels ((layer-index (object indices)
 							(if indices
 							    (layer-index (aref object (- (first indices)
 											 (of-state (local-idiom
												    april)
 												   :count-from)))
 									 (rest indices))
 							    object)))
 					       (let ((found (layer-index omega (array-to-list alpha))))
 						 (if (arrayp found)
 						     found (make-array (list 1)
 								       :element-type (element-type omega)
 								       :initial-element found)))))))
 	       (tests (is "⊃(1)(1 2)(1 2 3)" #2A((1 0 0) (1 2 0) (1 2 3)))
 		      (is "⊃[0.5](1)(1 2)(1 2 3)" #2A((1 1 1) (0 2 2) (0 0 3)))
 		      (is "⊃(2 3⍴⍳5)(4 2⍴⍳8)" #3A(((1 2 3) (4 5 1) (0 0 0) (0 0 0))
 						  ((1 2 0) (3 4 0) (5 6 0) (7 8 0))))
 		      (is "⊃[0.5](2 3⍴⍳5)(4 2⍴⍳8)" #3A(((1 4 0 0) (1 3 5 7)) ((2 5 0 0) (2 4 6 8))
 						       ((3 1 0 0) (0 0 0 0))))
 		      (is "⊃[1.5](2 3⍴⍳5)(4 2⍴⍳8)" #3A(((1 2 3) (4 5 1) (0 0 0) (0 0 0))
 						       ((1 2 0) (3 4 0) (5 6 0) (7 8 0))))
 		      (is "⊃2 2 2⍴(1)(1 2)(3 4)(1 2 3)" #4A((((1 0 0) (1 2 0)) ((3 4 0) (1 2 3)))
 							    (((1 0 0) (1 2 0)) ((3 4 0) (1 2 3)))))
 		      (is "2⊃(1 2 3)(4 5 6)(7 8 9)" #(4 5 6))
 		      (is "(2 2)⊃(1 2 3)(4 5 6)(7 8 9)" 5)))
 	    (∪ (has :titles ("Unique" "Union"))
 	       (ambivalent (args :any (lambda (omega)
 	    				(if (not (vectorp omega))
 	    				    (error "Argument must be a vector.")
 	    				    (let ((uniques nil))
 	    				      (dotimes (index (length omega))
 	    					(if (not (find (aref omega index)
 	    						       uniques :test #'array-compare))
 	    					    (setq uniques (cons (aref omega index)
 	    								uniques))))
 	    				      (make-array (list (length uniques))
 							  :element-type (element-type omega)
 	    						  :initial-contents (reverse uniques))))))
 	    		   (args :any :any (lambda (omega alpha)
 	    				     (if (or (not (vectorp alpha))
 	    					     (not (vectorp omega)))
 	    					 (error "Arguments must be vectors.")
 	    					 (let ((uniques nil)
 						       (is-string (and (eql 'character (element-type alpha))
 								       (eql 'character (element-type omega)))))
 	    					   (dotimes (index (length omega))
 	    					     (if (not (find (aref omega index)
 	    							    alpha :test #'array-compare))
 	    						 (setq uniques (cons (aref omega index)
 	    								     uniques))))
 	    					   (concatenate (if is-string 'string 'vector)
 								alpha
 	    							(make-array (list (length uniques))
 									    :element-type (if is-string
 											      'character t)
 	    								    :initial-contents
 	    								    (reverse uniques))))))))
 	       (tests (is "∪1 2 3 4 5 1 2 8 9 10 11 7 8 11 12" #(1 2 3 4 5 8 9 10 11 7 12))
 		      (is "∪'MISSISSIPPI'" "MISP")
 		      (is "3 10 14 18 11∪9 4 5 10 8 3" #(3 10 14 18 11 9 4 5 8))
 		      (is "'STEEL'∪'SABER'" "STEELABR")
 		      (is "'APRIL' 'MAY'∪'MAY' 'JUNE'" #("APRIL" "MAY" "JUNE"))))
 	    (∩ (has :title "Intersection")
 	       (dyadic (args :any :any (lambda (omega alpha)
 	    				 (if (or (not (vectorp alpha))
 	    					 (not (vectorp omega)))
 	    				     (error "Arguments must be vectors.")
 	    				     (let ((matches nil)
 						   (is-string (and (eql 'character (element-type alpha))
 								   (eql 'character (element-type omega)))))
 	    				       (dotimes (index (length alpha))
 	    					 (if (find (aref alpha index)
 	    						   omega :test #'array-compare)
 	    					     (setq matches (cons (aref alpha index)
 	    								 matches))))
 	    				       (make-array (list (length matches))
 							   :element-type (if is-string 'character t)
 	    						   :initial-contents (reverse matches)))))))
 	       (tests (is "'MIXTURE'∩'LATER'" "TRE")
 		      (is "'STEEL'∩'SABER'" "SEE")
 		      (is "1 4 8∩⍳5" #(1 4))))
 	    (⌽ (has :titles ("Reverse" "Rotate"))
 	       (ambivalent (args :any :axes (lambda (omega &optional axes)
 	    				      (if (vectorp omega)
 	    					  (let ((new-array (copy-array omega)))
 	    					    (funcall (make-rotator)
 	    						     new-array)
 	    					    new-array)
 	    					  (if (arrayp omega)
 	    					      (apply-marginal (make-rotator)
 	    							      omega (if axes (1- (aref (first axes) 0)))
 	    							      (1- (rank omega)))))))
 	    		   (args :any :one :axes
 	    			 (lambda (omega alpha &optional axes)
				   (let ((alpha (disclose alpha)))
				     (if (not (integerp alpha))
					 (error "The left argument to ⌽ must be a single integer, i.e. 2⌽⍳10.")
					 (if (vectorp omega)
					     (let ((new-array (copy-array omega)))
					       (funcall (make-rotator alpha)
							new-array)
					       new-array)
					     (if (arrayp omega)
						 (apply-marginal (make-rotator alpha)
								 omega (if axes (1- (aref (first axes) 0)))
								 (1- (rank omega))))))))))
 	       (tests (is "⌽1 2 3 4 5" #(5 4 3 2 1))
 	    	      (is "⌽3 4⍴⍳9" #2A((4 3 2 1) (8 7 6 5) (3 2 1 9)))
 	    	      (is "2⌽3 4⍴⍳9" #2A((3 4 1 2) (7 8 5 6) (2 3 9 1)))))
     	    (⊖ (has :titles ("Reverse First" "Rotate First"))
 	       (ambivalent (args :any :axes (lambda (omega &optional axes)
 	    				      (if (vectorp omega)
 	    					  (let ((new-array (copy-array omega)))
 	    					    (funcall (make-rotator)
 	    						     new-array)
 	    					    new-array)
 	    					  (if (arrayp omega)
 	    					      (apply-marginal (make-rotator)
 	    							      omega (if axes (1- (aref (first axes) 0)))
 	    							      0)))))
 	    		   (args :any :one :axes
 	    			 (lambda (omega alpha &optional axes)
				   (let ((alpha (disclose alpha)))
				     (if (not (integerp alpha))
					 (error "The left argument to ⊖ must be a single integer, i.e. 2⊖⍳10.")
					 (if (vectorp omega)
					     (let ((new-array (copy-array omega)))
					       (funcall (make-rotator alpha)
							new-array)
					       new-array)
					     (if (arrayp omega)
						 (apply-marginal (make-rotator alpha)
								 omega (if axes (1- (aref (first axes) 0)))
								 0))))))))
 	       (tests (is "⊖1 2 3 4 5" #(5 4 3 2 1))
 	    	      (is "⊖3 4⍴⍳9" #2A((9 1 2 3) (5 6 7 8) (1 2 3 4)))
 	    	      (is "1⊖3 4⍴⍳9" #2a((5 6 7 8) (9 1 2 3) (1 2 3 4)))))
 	    (⍉ (has :titles ("Transpose" "Permute"))
 	       (ambivalent (args :any (lambda (omega)
 	    				(aops:permute (reverse (alexandria:iota (rank omega)))
 	    					      omega)))
 	    		   (args :any :any (lambda (omega alpha)
 	    				     (aops:permute (mapcar (lambda (i)
 	    							     (- i (of-state (local-idiom april)
										    :count-from)))
 	    							   (array-to-list alpha))
 	    						   omega))))
 	       (tests (is "⍉2 3 4⍴⍳9" #3A(((1 4) (5 8) (9 3)) ((2 5) (6 9) (1 4))
 					  ((3 6) (7 1) (2 5)) ((4 7) (8 2) (3 6))))
 		      (is "1 3 2⍉2 3 4⍴⍳9" #3A(((1 5 9) (2 6 1) (3 7 2) (4 8 3))
 					       ((4 8 3) (5 9 4) (6 1 5) (7 2 6))))))
 	    (⌹ (has :titles ("Matrix Inverse" "Matrix Divide"))
 	       (ambivalent (args :any (lambda (omega)
 	    				(if (and (= 1 (rank omega))
 	    					 (= 1 (length omega)))
 	    				    (/ (disclose omega))
 	    				    (if (< 2 (rank omega))
 						(error "Matrix inversion only works on arrays of rank 2 or 1.")
 						(if (let ((odims (dims omega)))
 						      (and (= 2 (length odims))
 							   (= (first odims) (second odims))))
 						    (invert-matrix omega)
 						    (left-invert-matrix omega))))))
 	    		   (args :any :any (lambda (omega alpha)
 					     (array-inner-product (invert-matrix omega)
 								  alpha (lambda (arg1 arg2)
 									  (apply-scalar-dyadic #'* arg1 arg2))
 								  #'+))))
 	       (tests (is "⌹1 2 3 4" #(1/30 1/15 1/10 2/15))
 		      (is "⌹2 2⍴4 9 8 2" #2A((-1/32 9/64) (1/8 -1/16)))
 		      (is "⌹4 2⍴1 3 ¯4 9" #2A((3/14 -1/14 3/14 -1/14) (2/21 1/42 2/21 1/42)))
 		      (is "35 89 79⌹3 3⍴3 1 4 1 5 9 2 6 5" #(193/90 739/90 229/45))
 		      (is "(3 2⍴1 2 3 6 9 10)⌹3 3⍴1 0 0 1 1 0 1 1 1" #2A((1 2) (2 4) (6 4)))))
 	    (⍋ (has :titles ("Grade Up" "Grade Up By"))
 	       (ambivalent (args :any (lambda (omega) (grade omega (alpha-compare (of-state (local-idiom april)
 	    										    :atomic-vector)
 	    									  #'<=)
 							     (of-state (local-idiom april)
								       :count-from))))
 	    		   (args :any :any (lambda (omega alpha) (grade (if (vectorp alpha)
 									    (index-of alpha omega
										      (of-state (local-idiom april)
												:count-from))
 									    (array-grade alpha omega))
 	    								(alpha-compare (of-state (local-idiom
												  april)
 	    											 :atomic-vector)
 	    									       #'<)
 									(of-state (local-idiom april)
										  :count-from)))))
 	       (tests (is "⍋8 3 4 9 1 5 2" #(5 7 2 3 6 1 4))
 		      (is "⍋5 6⍴⍳16" #(1 4 2 5 3))
		      (is "st←'aodjeignwug' ⋄ st[⍋st]" "adeggijnouw")
 		      (is "(2 5⍴'ABCDEabcde')⍋'ACaEed'" #(1 3 2 6 4 5))))
 	    (⍒ (has :titles ("Grade Down" "Grade Down By"))
 	       (ambivalent (args :any (lambda (omega) (grade omega (alpha-compare (of-state (local-idiom april)
 	    										    :atomic-vector)
 	    									  #'>=)
 							     (of-state (local-idiom april)
								       :count-from))))
 	    		   (args :any :any (lambda (omega alpha) (grade (if (vectorp alpha)
 									    (index-of alpha omega
										      (of-state (local-idiom april)
												:count-from))
 									    (array-grade alpha omega))
 	    								(alpha-compare (of-state
											(local-idiom april)
											:atomic-vector)
 	    									       #'>)
 									(of-state (local-idiom april)
										  :count-from)))))
 	       (tests (is "⍒6 1 8 2 4 3 9" #(7 3 1 5 6 4 2))
 		      (is "⍒5 6⍴⍳12" #(2 4 1 3 5))
		      (is "st←'aodjeignwug' ⋄ st[⍒st]" "wuonjiggeda")
 		      (is "(2 5⍴'ABCDEabcde')⍒'ACaEed'" #(5 4 6 2 3 1))))
 	    (⊤ (has :title "Encode")
 	       (dyadic (args :any :any (lambda (omega alpha)
 	    				 (flet ((rebase (bases number)
 	    					  (let ((operand number)
 	    						(last-base 1)
 	    						(base 1)
 	    						(component 1)
 	    						(element nil))
 	    					    (loop for index from (1- (length bases)) downto 0
 	    					       do (setq last-base base
 	    							base (* base (aref bases index))
 	    							component (if (= 0 base)
 	    								      operand
 	    								      (* base
 	    									 (nth-value 1 (floor (/ operand
 	    												base)))))
 	    							operand (- operand component)
 	    							element (/ component last-base))
 	    					       collect element))))
 	    				   (if (= 1 (length omega))
 	    				       (let ((result (rebase alpha (aref omega 0))))
 	    					 (make-array (list (length result))
 	    						     :initial-contents (reverse result)))
 	    				       (aops:permute (list 1 0)
 	    						     (make-array (list (length omega) (length alpha))
 	    								 :initial-contents
 	    								 (mapcar (lambda (item)
 	    									   (reverse (rebase alpha item)))
 	    									 (array-to-list omega)))))))))
 	       (tests (is "1760 3 12⊤82" #(2 0 10))
 		      (is "16 16 16 16⊤100" #(0 0 6 4))
 		      (is "2 2 2 2 2⊤1 2 3 4 5" #2A((0 0 0 0 0) (0 0 0 0 0) (0 0 0 1 1)
 						    (0 1 1 0 0) (1 0 1 0 1)))))
 	    (⊥ (has :title "Decode")
 	       (dyadic (args :any :any (lambda (omega alpha)
 	    				 (flet ((rebase (bases numerators)
 	    					  (let ((result 0)
 	    						(base 1))
 	    					    (loop for index from (1- (length numerators)) downto 0
 	    					       do (incf result (* base (aref numerators index)))
 	    						 (setf base (* base (aref bases index))))
 	    					    result)))
 	    				   (let ((bases (if (= 1 (length alpha))
 	    						    (make-array (list (first (dims omega)))
 	    								:initial-element (aref alpha 0))
 	    						    (if (not (= (length alpha)
 	    								(let ((d-o (dims omega)))
 	    								  (if (= 1 (length d-o))
 	    								      (first d-o)
 	    								      (second d-o)))))
 	    							(error "Base/element length mismatch.")
 	    							alpha))))
 	    				     (if (= 1 (rank omega))
 	    					 (vector (rebase bases omega))
 	    					 (aops:margin (lambda (sub-array) (rebase bases sub-array))
 	    						      omega 0)))))))
 	       (tests (is "10⊥2 6 7 1" 2671)
 		      (is "1760 3 12⊥2 2 5" 101)
 		      (is "1760 3 12⊥3 3⍴1 2 1 5 0 2 2 3 7" #(98 75 67))))
 	    (⍎ (has :title "Evaluate")
 	       (monadic (macro (lambda (meta axes omega)
 				 (declare (ignore meta axes))
 				 `(april ,omega))))
 	       (tests (is "⍎'1+1'" 2)))
 	    ;; (∘ (has :title "Find Outer Product, Not Inner")
	    ;;    (symbolic :outer-product-designator))
	    )

 (operators ;; (← (has :title "Assign Result Of")
 	    ;;    (lateral (lambda (meta axes right-function)
	    ;; 		  (declare (ignore meta axes))
	    ;; 		  (lambda (meta unused omega alpha)
	    ;; 		    (declare (ignore unused))
	    ;; 		    (if (and (listp alpha)
	    ;; 			     (eql 'aref-eliding (first alpha)))
	    ;; 			(append alpha (list :set `(lambda (item coords)
	    ;; 						    (declare (ignore coords))
	    ;; 						    (funcall (lambda (omega alpha)
	    ;; 							       ,(funcall right-function
	    ;; 									 meta nil 'omega 'alpha))
	    ;; 							     ,omega item))))
	    ;; 			(let ((symbol (if (listp alpha)
	    ;; 					  (second alpha)
	    ;; 					  alpha)))
	    ;; 			  `(setq ,symbol (funcall (lambda (omega alpha)
	    ;; 						    ,(funcall right-function meta nil 'omega 'alpha))
	    ;; 						  ,omega ,alpha)))))))
 	    ;;    (tests (is "a←3 2 1 ⋄ a+←5 ⋄ a" #(8 7 6))
 	    ;; 	      (is "a←3 2 1 ⋄ a[2]+←5 ⋄ a" #(3 7 1))))
 	    ;; (/ (has :title "Reduce")
 	    ;;    (lateral (lambda (meta axes function)
	    ;; 		  (declare (ignore meta))
	    ;; 		  (over-operator-template axes function
	    ;; 					  :for-vector (lambda (function input)
	    ;; 							(vector (reduce function input)))
	    ;; 					  :for-array (lambda (function input axis)
	    ;; 						       (aops:margin (lambda (s) (reduce function s))
	    ;; 								    input axis)))))
 	    ;;    (tests (is "+/1 2 3 4 5" 15)
 	    ;; 	      (is "+/3 4⍴⍳12" #(10 26 42))
 	    ;; 	      (is "+/[1]3 4⍴⍳12" #(15 18 21 24))
	    ;; 	      (is "fn←{⍺+⍵} ⋄ fn/1 2 3 4 5" 15)
 	    ;; 	      (is "⌊10000×{⍺+÷⍵}/40/1" 16180)))
  	    ;; (⌿ (has :title "Reduce First")
 	    ;;    (lateral (lambda (meta axes function)
	    ;; 		  (declare (ignore meta))
	    ;; 		  (over-operator-template axes function :first-axis t
	    ;; 					  :for-vector (lambda (function input)
	    ;; 							(vector (reduce function input)))
	    ;; 					  :for-array (lambda (function input axis)
	    ;; 						       (aops:margin (lambda (s) (reduce function s))
	    ;; 								    input axis)))))
 	    ;;    (tests (is "+⌿3 4⍴⍳12" #(15 18 21 24))
	    ;; 	      (is "{⍺×⍵+3}⌿3 4⍴⍳12" #(207 330 495 708))
 	    ;; 	      (is "+⌿[2]3 4⍴⍳12" #(10 26 42))))
 	    ;; (\\ (has :title "Scan")
	    ;; 	(lateral (lambda (meta axes function)
	    ;; 		   (declare (ignore meta))
	    ;; 		   (over-operator-template axes function
	    ;; 					   :for-vector (lambda (function input)
	    ;; 							 (funcall (make-back-scanner function)
	    ;; 								  input))
	    ;; 					   :for-array (lambda (function input axis)
	    ;; 							(apply-marginal (make-back-scanner function)
	    ;; 									input axis (1- (rank input)))))))
 	    ;; 	(tests (is "+\\1 2 3 4 5" #(1 3 6 10 15))
 	    ;; 	       (is "+\\3 4⍴⍳12" #2A((1 3 6 10) (5 11 18 26) (9 19 30 42)))
 	    ;; 	       (is "+\\[1]3 4⍴⍳12" #2A((1 2 3 4) (6 8 10 12) (15 18 21 24)))))
 	    ;; (⍀ (has :title "Scan First")
 	    ;;    (lateral (lambda (meta axes function)
	    ;; 		  (declare (ignore meta))
	    ;; 		  (over-operator-template axes function :first-axis t
	    ;; 					  :for-vector (lambda (function input)
	    ;; 							(funcall (make-back-scanner function)
	    ;; 								 input))
	    ;; 					  :for-array (lambda (function input axis)
	    ;; 						       (apply-marginal (make-back-scanner function)
	    ;; 								       input axis (1- (rank input)))))))
 	    ;;    (tests (is "+⍀1 2 3 4 5" #(1 3 6 10 15))
 	    ;; 	      (is "+⍀3 4⍴⍳12" #2A((1 2 3 4) (6 8 10 12) (15 18 21 24)))
	    ;; 	      (is "{⍺×⍵+3}⍀3 4⍴⍳12" #2A((1 2 3 4) (20 30 42 56) (288 450 660 924)))
 	    ;; 	      (is "+⍀[2]3 4⍴⍳12" #2A((1 3 6 10) (5 11 18 26) (9 19 30 42)))))
 	    ;; (\. (has :title "Inner/Outer Product")
 	    ;; 	(pivotal (lambda (meta axes left-operand)
	    ;; 		   (declare (ignore meta axes))
	    ;; 		   (if (eq :outer-product-designator left-operand)
	    ;; 		       (lambda (meta axes right-function)
	    ;; 			 (declare (ignore meta axes))
	    ;; 			 (lambda (meta unused omega alpha)
	    ;; 			   (declare (ignore unused))
	    ;; 			   (let ((fn-clause (funcall right-function meta nil 'omega 'alpha)))
	    ;; 			     `(if (is-singleton ,omega)
	    ;; 				  (aops:each (lambda (element)
	    ;; 					       (let ((alpha element)
	    ;; 						     (omega (disclose ,omega)))
	    ;; 						 (disclose ,fn-clause)))
	    ;; 					     ,alpha)
	    ;; 				  (let ((inverse (aops:outer (lambda (omega alpha)
	    ;; 							       (let ((omega (enclose omega))
	    ;; 								     (alpha (enclose alpha)))
	    ;; 								 (if (is-singleton omega)
	    ;; 								     ;; swap arguments in case of a
	    ;; 								     ;; singleton omega argument
	    ;; 								     (let ((placeholder alpha))
	    ;; 								       (setq alpha omega
	    ;; 									     omega placeholder)))
	    ;; 								 (disclose ,fn-clause)))
	    ;; 							     ,alpha ,omega)))
	    ;; 				    (if (not (is-singleton ,alpha))
	    ;; 					inverse (aops:permute (reverse (alexandria:iota (rank inverse)))
	    ;; 							      inverse)))))))
	    ;; 		       (lambda (meta axes right-function)
	    ;; 			 (declare (ignore meta axes))
	    ;; 			 (lambda (meta unused omega alpha)
	    ;; 			   (declare (ignore unused))
	    ;; 			   `(if (and (vectorp ,omega)
	    ;; 				     (vectorp ,alpha))
	    ;; 				(make-array (list 1)
	    ;; 					    :initial-element
	    ;; 					    (reduce (lambda (omega alpha)
	    ;; 						      ,(funcall left-operand meta nil 'omega 'alpha))
	    ;; 						    (apply-scalar-dyadic
	    ;; 						     (lambda (omega alpha)
	    ;; 						       ,(funcall right-function meta nil 'omega 'alpha))
	    ;; 						     ,alpha ,omega)))
	    ;; 				(array-inner-product ,alpha ,omega
	    ;; 						     (let ((f1 (lambda (omega alpha)
	    ;; 								 ,(funcall right-function
	    ;; 									   meta nil 'omega 'alpha))))
	    ;; 						       (lambda (arg1 arg2)
	    ;; 							 (if (or (arrayp arg1)
	    ;; 								 (arrayp arg2))
	    ;; 							     (apply-scalar-dyadic f1 arg1 arg2)
	    ;; 							     (funcall f1 arg1 arg2))))
	    ;; 						     (lambda (omega alpha)
	    ;; 						       ,(funcall left-operand
	    ;; 								 meta nil 'omega 'alpha)))))))))
 	    ;; 	(tests (is "2+.×3 4 5" 24)
	    ;; 	       (is "2 3 4+.×8 15 21" 145)
 	    ;; 	       (is "2 3 4+.×3 3⍴3 1 4 1 5 9 2 6 5" #(17 41 55))
 	    ;; 	       (is "(3 3⍴3 1 4 1 5 9 2 6 5)+.×2 3 4" #(25 53 42))
 	    ;; 	       (is "4 5 6∘.+20 30 40 50" #2A((24 34 44 54) (25 35 45 55) (26 36 46 56)))
	    ;; 	       (is "1 2 3∘.-1 2 3" #2A((0 -1 -2) (1 0 -1) (2 1 0)))
	    ;; 	       (is "1 2 3∘.⍴1 2 3" #2A((1 2 3) (#(1 1) #(2 2) #(3 3)) (#(1 1 1) #(2 2 2) #(3 3 3))))
	    ;; 	       (is "1 2 3∘.⍴⊂1 2 3" #(1 #(1 2) #(1 2 3)))
	    ;; 	       (is "1 2 3∘.⌽⊂1 2 3" #(#(2 3 1) #(3 1 2) #(1 2 3)))
	    ;; 	       (is "1 2 3∘.⌽[1]⊂4 5 6 7" #(#(5 6 7 4) #(6 7 4 5) #(7 4 5 6)))))
 	    ;; (\¨ (has :title "Each")
 	    ;; 	(lateral (lambda (meta axes function)
	    ;; 		   (declare (ignore meta axes))
	    ;; 		   (lambda (meta axes omega &optional alpha)
	    ;; 		     (declare (ignore axes))
	    ;; 		     (let ((index (gensym)))
	    ;; 		       `(let ((new-array (copy-array ,omega)))
	    ;; 			  ,(if alpha
	    ;; 			       `(let ((right-arg ,alpha))
	    ;; 				  (make-array (dims right-arg)
	    ;; 					      :initial-contents
	    ;; 					      (loop :for ,index :from 0 :to (1- (length right-arg))
	    ;; 						 :collect (disclose (funcall
	    ;; 								     (lambda (omega alpha)
	    ;; 								       ,(funcall function
	    ;; 										 meta nil 'omega 'alpha))
	    ;; 								     (aref new-array 0)
	    ;; 								     (vector (aref right-arg ,index)))))))
	    ;; 			       `(aops:each (lambda (item)
	    ;; 					     (disclose (funcall (lambda (omega)
	    ;; 								  ,(funcall function meta nil 'omega))
	    ;; 								item)))
	    ;; 					   new-array)))))))
	    ;; 	(tests (is "⍳¨1 2 3" #(1 #(1 2) #(1 2 3)))
	    ;; 	       (is "1 ¯1⌽¨⊂1 2 3 4 5" #(#(2 3 4 5 1) #(5 1 2 3 4)))))
 	    (⍨ (has :title "Commute")
	       (lateral (lambda (operand workspace)
			  `(lambda (omega &optional alpha)
			     (apl-call ,(if (not (characterp operand))
					   operand (get-function-data (local-idiom april)
								      operand :dyadic))
				       (if alpha alpha omega)
				       omega))))
 	       (tests (is "5-⍨10" 5)
		      (is "+⍨10" 20)))
 	    (∘ (has :title "Compose")
 	       (pivotal (lambda (right left workspace)
			  (flet ((is-fn (item)
				   (or (characterp item)
				       (and (listp item)
					    (eql 'lambda (first item))))))
			    `(lambda (omega &optional alpha)
			       ,(cond ((and (is-fn right)
					    (is-fn left))
				       `(apl-call (if alpha
						      ,@(loop for type in (list :dyadic :monadic)
							   collect (if (not (characterp left))
								       left (get-function-data (local-idiom april)
											       left type))))
						  (apl-call ,(if (not (characterp right))
								 right (get-function-data (local-idiom april)
											  right :monadic))
							    omega)
						  alpha))
				      (t `(apl-call ,(get-function-data (local-idiom april)
									(if (is-fn right) right left)
									:dyadic)
						    ,(if (not (is-fn right))
							 right 'omega)
						    ,(if (not (is-fn left))
							 left 'omega))))))))
 	       (tests (is "fn←⍴∘⍴ ⋄ fn 2 3 4⍴⍳9" 3)
 	    	      (is "⍴∘⍴2 3 4⍴⍳9" 3)
 	    	      (is "⍴∘⍴∘⍴2 3 4⍴⍳9" 1)
	    	      (is "(÷∘5) 30" 6)
	    	      (is "⌊10000×(+∘*∘0.5)4 16 25" #(56487 176487 266487))
	    	      (is "fn←5∘- ⋄ fn 2" 3)
	    	      (is "⌊(0.5∘+∘*)5 8 12" #(148 2981 162755))
 	    	      (is "⌊10000×+∘÷/40/1" 16180)
	    	      (is "+/∘⍳¨2 5 8" #(3 15 36))))
	    ;; (⍤ (has :title "Rank")
	    ;;    (pivotal (lambda (meta axes left-operand)
	    ;; 		  (declare (ignore meta axes))
	    ;; 		  (lambda (meta axes right-operand)
	    ;; 		    (let* ((item (gensym)) (orank (gensym)) (encr (gensym))
	    ;; 			   (at-omega (second right-operand)))
	    ;; 		      `(lambda (omega &optional alpha)
	    ;; 			 (let ((,orank (rank omega)))
	    ;; 			   (if (= ,orank ,at-omega)
	    ;; 			       (vector ,(funcall left-operand meta axes 'omega 'alpha))
	    ;; 			       (let ((,encr (make-array (list ,at-omega)
	    ;; 							:initial-contents
	    ;; 							(iota ,at-omega
	    ;; 							      :start (- ,orank (1- ,at-omega)
	    ;; 									(of-state (local-idiom april)
	    ;; 										  :count-from))))))
	    ;; 				 (mix-arrays 0 (aops:each (lambda (,item)
	    ;; 							    (vector ,(funcall left-operand
	    ;; 									      meta axes item 'alpha)))
	    ;; 							  (re-enclose omega ,encr))
	    ;; 					     :disclose-items t))))))))))
 	    ;; (⍣ (has :title "Power")
 	    ;;    (pivotal (lambda (meta axes left-function)
	    ;; 		  (declare (ignore meta axes))
	    ;; 		  (lambda (meta axes right-operand)
	    ;; 		    (declare (ignore axes))
	    ;; 		    (cond ((and (listp right-operand)
	    ;; 				(not (eql 'lambda (first right-operand))))
	    ;; 			   (let ((arg (gensym))
	    ;; 				 (index (gensym)))
	    ;; 			     `(lambda (omega &optional alpha)
	    ;; 				(declare (ignorable alpha))
	    ;; 				(let ((,arg (disclose omega)))
	    ;; 				  (loop :for ,index :from 0 :to (1- (disclose ,right-operand))
	    ;; 				     :do (setq ,arg (enclose ,(funcall left-function meta nil arg))))
	    ;; 				  ,arg))))
	    ;; 			  ((listp right-operand)
	    ;; 			   (let ((arg (gensym))
	    ;; 				 (prior-arg (gensym)))
	    ;; 			     `(lambda (omega &optional alpha)
	    ;; 				(declare (ignorable alpha))
	    ;; 				(let ((,arg omega)
	    ;; 				      (,prior-arg omega))
	    ;; 				  (loop :while (= 0 (funcall ,right-operand ,prior-arg ,arg))
	    ;; 				     :do (setq ,prior-arg ,arg
	    ;; 					       ,arg (enclose ,(funcall left-function meta nil arg))))
	    ;; 				  ,arg))))))))
 	    ;;    (tests (is "fn←{2+⍵}⍣3 ⋄ fn 5" 11)
 	    ;; 	      (is "({2+⍵}⍣3) 9" 15)
 	    ;; 	      (is "fn←{2+⍵}⍣{10<⍺} ⋄ fn 2" 12)
	    ;; 	      (is "fn←{2+⍵}⍣{10<⍵} ⋄ fn 2" 14)))
	    ;; (@ (has :title "At")
	    ;;    (pivotal (lambda (meta axes left-operand)
	    ;; 		  (declare (ignore meta axes))
	    ;; 		  (lambda (meta axes right-operand)
	    ;; 		    (let* ((index (gensym)) (new-array (gensym)) (mask (gensym)) (alpha-var (gensym))
	    ;; 			   (omega-var (gensym)) (aix (gensym)) (ix (gensym))
	    ;; 			   (item (gensym)) (coords (gensym))
	    ;; 			   (at-omega (cond ((listp right-operand)
	    ;; 					    right-operand)
	    ;; 					   ((functionp right-operand)
	    ;; 					    (funcall right-operand meta axes 'omega))))
	    ;; 			   (at-alpha (cond ((listp left-operand)
	    ;; 					    left-operand)
	    ;; 					   ((or (functionp left-operand)
	    ;; 						(functionp right-operand))
	    ;; 					    (funcall left-operand meta axes 'omega))
	    ;; 					   (t (funcall left-operand meta axes
	    ;; 						       `(let* ((,new-array
	    ;; 								(make-array (list (length ,at-omega))
	    ;; 									    :initial-element nil)))
	    ;; 							  (loop :for ,index :from 0
	    ;; 							     :to (1- (length ,at-omega))
	    ;; 							     :do (setf (aref ,new-array ,index)
	    ;; 								       (aref omega
	    ;; 									     (- (aref ,at-omega ,index)
	    ;; 										(of-state
	    ;; 										 (local-idiom april)
	    ;; 										 :count-from)))))
	    ;; 							  ,new-array)))))
	    ;; 			   (set `(lambda (,item ,coords)
	    ;; 				   (declare (ignore ,item))
	    ;; 				   (if (is-singleton ,alpha-var)
	    ;; 				       (disclose ,alpha-var)
	    ;; 				       (let* ((,ix (if (listp ,index)
	    ;; 						       ,index (list ,index)))
	    ;; 					      (,aix ,(if (functionp left-operand)
	    ;; 							 coords `(append ,ix (nthcdr (length ,ix)
	    ;; 										     ,coords)))))
	    ;; 					 (declare (ignorable ,ix))
	    ;; 					 (disclose (aref-eliding ,alpha-var (if (listp ,aix)
	    ;; 										,aix (list ,aix)))))))))
	    ;; 		      (declare (ignorable set))
	    ;; 		      (cond ((functionp right-operand)
	    ;; 			     (lambda (meta axes omega &optional alpha)
	    ;; 			       (declare (ignore omega alpha))
	    ;; 			       (let ((index (gensym)))
	    ;; 				 `(lambda (omega)
	    ;; 				    (let ((,mask ,(funcall right-operand meta axes 'omega)))
	    ;; 				      (loop :for ,index :from 0 :to (1- (length omega))
	    ;; 					 :do (if (/= 0 (aref ,mask ,index))
	    ;; 						 (setf (aref omega ,index)
	    ;; 						       ,(if (functionp left-operand)
	    ;; 							    `(aref ,at-alpha ,index)
	    ;; 							    `(aref ,at-alpha 0)))))
	    ;; 				      omega)))))
	    ;; 			    ((eql 'lambda (first right-operand))
	    ;; 			     `(lambda (omega)
	    ;; 				(let ((,mask (funcall ,right-operand omega)))
	    ;; 				  (loop :for ,index :from 0 :to (1- (length omega))
	    ;; 				     :do (if (/= 0 (aref ,mask ,index))
	    ;; 					     (setf (aref omega ,index)
	    ;; 						   ,(if (functionp left-operand)
	    ;; 							`(aref ,at-alpha ,index)
	    ;; 							`(aref ,at-alpha 0)))))
	    ;; 				  omega)))
	    ;; 			    (t `(lambda (omega)
	    ;; 				  (let* ((,alpha-var ,at-alpha)
	    ;; 					 (,omega-var (apply-scalar-dyadic #'- ,at-omega
	    ;; 									  (of-state (local-idiom april)
	    ;; 										    :count-from))))
	    ;; 				    (loop :for ,index :from 0 :to (1- (length ,omega-var))
	    ;; 				       :do (aref-eliding omega (array-to-list (aref ,omega-var ,index))
	    ;; 							 :set ,set))
	    ;; 				    omega))))))))
	    ;;    (tests (is "(20 20@3 8) ⍳9" #(1 2 20 4 5 6 7 20 9))
	    ;; 	      (is "((2 5⍴0 1)@2 5) 5 5⍴⍳9" #2A((1 2 3 4 5) (0 1 0 1 0) (2 3 4 5 6)
	    ;; 					       (7 8 9 1 2) (1 0 1 0 1)))
	    ;; 	      (is "(0@(3∘|)) ⍳9" #(0 0 3 0 0 6 0 0 9))
	    ;; 	      (is "(÷@3 5) ⍳9" #(1 2 1/3 4 1/5 6 7 8 9))
	    ;; 	      (is "({⍵×2}@{⍵>3}) ⍳9" #(1 2 3 8 10 12 14 16 18))))
	    )

 (general-tests (with :title "Basic function definition and use, with comments."
 		      :in ("⍝ This code starts with a comment.
    f1←{⍵+3} ⋄ f2←{⍵×2} ⍝ A comment after the functions are defined.
    ⍝ This is another comment.
    f2 f1 1 2 3 4 5")
 		      :ex #(8 10 12 14 16))
 		(with :title "Monadic inline function."
 		      :in ("{⍵+3} 3 4 5")
 		      :ex #(6 7 8))
 		(with :title "Dyadic inline function."
 		      :in ("1 2 3 {⍺×⍵+3} 3 4 5")
 		      :ex #(6 14 24))
		(with :title "Vector of input variables and discrete values processed within a function."
		      :in ("fn←{3+⍵} ⋄ {fn 8 ⍵} 9")
		      :ex #(11 12))
 		(with :title "Variable-referenced values, including an element within an array, in a vector."
 		      :in ("a←9 ⋄ b←2 3 4⍴⍳9 ⋄ 1 2 a 3 b[1;2;1]")
 		      :ex #(1 2 9 3 5))
		(with :title "Application of functions to indexed array elements."
		      :in ("g←2 3 4 5 ⋄ 9,g[2],3 4")
		      :ex #(9 3 3 4))
 		(with :title "Assignment of an element within an array."
 		      :in ("a←2 3⍴⍳9 ⋄ a[1;2]←20 ⋄ a")
 		      :ex #2A((1 20 3) (4 5 6)))
 		(with :title "Selection from an array with multiple elided dimensions."
 		      :in ("(2 3 3 4 5⍴⍳9)[2;;3;;2]")
 		      :ex #2A((6 2 7 3) (3 8 4 9) (9 5 1 6)))
 		(with :title "Elided assignment."
 		      :in ("a←2 3 4⍴⍳9 ⋄ a[2;;3]←0 ⋄ a")
 		      :ex #3A(((1 2 3 4) (5 6 7 8) (9 1 2 3)) ((4 5 0 7) (8 9 0 2) (3 4 0 6))))
 		(with :title "Elided assignment of applied function's results."
 		      :in ("a←2 3 4⍴⍳9 ⋄ a[2;;3]+←10 ⋄ a")
 		      :ex #3A(((1 2 3 4) (5 6 7 8) (9 1 2 3)) ((4 5 16 7) (8 9 11 2) (3 4 15 6))))
		(with :title "Elision and indexed array elements."
		      :in ("(6 8⍴⍳9)[1 4;]")
		      :ex #2A((1 2 3 4 5 6 7 8) (7 8 9 1 2 3 4 5)))
		(with :title "As above but more complex."
		      :in ("(6 8 5⍴⍳9)[1 4;;2 1]")
		      :ex #3A(((2 1) (7 6) (3 2) (8 7) (4 3) (9 8) (5 4) (1 9))
			      ((5 4) (1 9) (6 5) (2 1) (7 6) (3 2) (8 7) (4 3))))
		(with :title "Indices of indices."
		      :in ("(6 8 5⍴⍳9)[1 4;;2 1][1;2 4 5;]")
		      :ex #2A((7 6) (8 7) (4 3)))
		(with :title "Operation over portions of an array."
		      :in ("a←4 8⍴⍳9 ⋄ a[2 4;1 6 7 8]+←10 ⋄ a")
		      :ex #2A((1 2 3 4 5 6 7 8) (19 1 2 3 4 15 16 17)
			      (8 9 1 2 3 4 5 6) (17 8 9 1 2 13 14 15)))))







(progn



  (set-composer-primitives
   composer-primitives-apl-standard
   (with :tokens-symbol tokens :idiom-symbol idiom :space-symbol space
	 :properties-symbol properties :processor-symbol process)
   ;; match an array, either inline line "1 2 3", referenced by a variable, or contained within a (closure)
   (array (destructure-tokens-array tokens idiom space properties process))
   ;; match a function, whether lexical like ⍳, symbolic like fn, or inline like {⍵+5}
   (function (destructure-tokens-function tokens idiom space properties process))
   ;; match a reference to an operator, this must be a lexical reference like ⍣
   (operator (destructure-tokens-operator tokens idiom space properties process)))
  
  (composer-primitives-apl-standard *april-idiom*)







  
  (set-composer-patterns
   composer-opening-patterns-apl-standard
   (with :idiom-symbol idiom :space-symbol space :process-symbol process :properties-symbol properties)
   (value
    ;; match an array like 1 2 3, marking the beginning of an array expression
    ;; ...or a functional expression if the array is an operand to a pivotal operator
    ((value :element array :times :any))
    (let ((value (output-value value properties)))
      value)
    (list :type (list :array :explicit)))
   (function
    ;; match a function like × or {⍵+10}, marking the beginning of a functional expression
    ((function-element :element function :times 1))
    function-element
    (list :type (list :function :symbol-function)
	  :axes (getf (first properties) :axes)))
   (lateral-composition
    ;; match a lateral function composition like +/, marking the beginning of a functional expression
    ((operator :element (operator :valence :lateral))
     (operand :pattern (:type (:function))))
    (funcall (get-operator-data idiom operator :lateral)
	     operand space)
    (list :type (list :function :operator-composed :lateral))))

  (progn (setf (vex::idiom-composer-opening-patterns *april-idiom*) nil)
	 (composer-opening-patterns-apl-standard *april-idiom*))







  
  (set-composer-patterns
   composer-following-patterns-apl-standard
   (with :idiom-symbol idiom :space-symbol space :process-symbol process
	 :properties-symbol properties :precedent-symbol precedent)
   (value-assignment
    ;; match a value assignment like a←1 2 3, part of an array expression
    ((:with-preceding-type :array)
     (assignment-function :element (function :glyph ←))
     (symbol :element (array :symbol-overriding t)))
    (progn (setf (gethash symbol (gethash :values space))
		 precedent)
	   (if (gethash symbol (gethash :functions space))
	       (setf (gethash symbol (gethash :functions space))
		     nil))
	   `(setq ,symbol ,precedent))
    (list :type (list :array :assigned)))
   (function-assignment
    ;; match a function assignment like f←{⍵×2}, part of a functional expression
    ((:with-preceding-type :function)
     (assignment-function :element (function :glyph ←))
     (symbol :element (array :symbol-overriding t)))
    (progn (setf (gethash symbol (gethash :functions space))
		 precedent)
	   (if (gethash symbol (gethash :values space))
	       (setf (gethash symbol (gethash :values space))
		     nil))
	   `(setq ,symbol ,precedent)))
   (pivotal-composition
    ;; match a pivotal function composition like ×.+, part of a functional expression
    ;; it may come after either a function or an array, since some operators take array operands
    ((operator :element (operator :valence :pivotal))
     (operand :pattern (:match :any)))
    (funcall (get-operator-data idiom operator :pivotal)
	     precedent operand space)
    (list :type (list :function :operator-composed :pivotal)))
   (operation
    ;; match an operation on arrays like 1+1 2 3, ⍳9 or +/⍳5, these operations are the basis of APL
    ((:with-preceding-type :array)
     (fn-element :pattern (:type (:function)))
     (value :element array :times :any :optional t))
    (let ((fn-content (if (not (characterp fn-element))
			  fn-element (get-function-data idiom fn-element (if value :dyadic :monadic))))
	  (axes (getf (first properties) :axes)))
      `(apl-call ,fn-content ,precedent ,@(if value (list (output-value value (rest properties))))
		 ,@(if axes `((list ,@(first axes))))))
    (list :type (list :array :evaluated))))

  (progn (setf (vex::idiom-composer-following-patterns *april-idiom*) nil)
	 (composer-following-patterns-apl-standard *april-idiom*)))
